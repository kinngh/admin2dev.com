<html lang="es-ES"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Curso Apex Starter | Admin2Dev</title>
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@500&amp;family=Spartan:wght@500;600;700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Muli:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="../assets/css/stylesheet.css">

  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

  <meta property="og:site_name" content="Admin2Dev">

  <meta property="og:title" content="Governor Limits and Batch Apex"> <!-- Content Title-->
  <meta property="og:description" content="Learn to write Batch Apex classes and what Governor Limits are in Salesforce"> <!-- Content Description -->
  <meta property="og:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:url" content="https://admin2dev.com/">


  <meta property="article:author" content="https://twitter.com/kinngh">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Governor Limits and Batch Apex"> <!-- Twitter Title -->
  <meta name="twitter:description" content="Learn to write Batch Apex classes and what Governor Limits are in Salesforce"> <!-- Twitter description -->
  <meta name="twitter:url" content="https://admin2dev.com">
  <meta name="twitter:label1" content="Written by">
  <meta name="twitter:data1" content="Harshdeep Singh Hura">
  <meta name="twitter:label2" content="Filed under">
  <meta name="twitter:data2" content="Apex Tutorials">
  <meta name="twitter:site" content="@kinngh">
  <meta name="twitter:creator" content="@kinngh">
  <meta name="twitter:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-112097931-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-112097931-2');
</script><script async="" src="https://hm-ackee.herokuapp.com/tracker.js" data-ackee-server="https://hm-ackee.herokuapp.com" data-ackee-domain-id="44278298-d601-4fe2-8430-af54e1945ef8"></script>

</head>

<body id="myBody" class="global-hash-post-card-amber global-hash-post-card-apricot global-hash-post-card-aqua global-hash-post-card-coral global-hash-post-card-cream global-hash-post-card-green global-hash-post-card-purple global-hash-post-card-raspberry global-hash-post-card-sky global-hash-dark-version is-loaded">
  <div class="global-wrap">
    <div class="global-content">
      <header class="header-section">
        <div class="header-wrap">
          <div class="header-logo">
            <a href="../index.html" class="is-image">
              <img src="../images/logo.png" alt="Admin2Dev">
            </a>
          </div>
          <div class="header-nav">
            <input id="toggle" class="header-checkbox" type="checkbox">
            <label class="header-toggle" for="toggle">
              <span>
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
              </span>
            </label>
            <nav>
              <ul>
                <li><a href="../index.html">Inicio</a></li>
                <li><a href="../learn/index.html">Aprender</a></li>
<li><a href="../tools/index.html">Herramientas</a></li>
                 <li><a href="../sponsor/index.html">Patrocinador</a></li>
                <li class="header-nav-dropdown">
                  <svg role="img" viewBox="0 0 20 4" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 4A2 2 0 102.001.001 2 2 0 002 4zm8 0a2 2 0 10.001-3.999A2 2 0 0010 4zm8 0a2 2 0 10.001-3.999A2 2 0 0018 4z"></path></svg>
                  <ul>
                    <li><a href="../about/index.html">Acerca de</a></li><li><a href="../terms.html">Condiciones del servicio</a></li>
                    <li><a href="../privacy.html">Política de privacidad</a></li>
                  </ul>
                </li>
              </ul>
              <ul>
                <li class="signup global-button"><a href="https://discord.gg/5ndr5F8" target="_blank">Únete a la comunidad</a></li>
                <li class="signin"><a onclick="darkMode()" id="darkModeText">Modo de luz</a></li>
              </ul>
            </nav>
          </div>
        </div>
      </header>
      <main class="global-main">
        <article class="post-section">
          <div class="post-header item is-hero is-page is-first post no-image page">
            <div class="item-container global-color">
              <div class="item-content">
                <h2 class="item-title">Límites del gobernador y ápice por lotes</h2>
              </div>
            </div>
          </div>
          <div class="post-content">
            <h2>Límites del gobernador</h2>
            <p>Salesforce, siendo el entorno multiinquilino que es, tiene que garantizar que los recursos estén disponibles para todos para garantizar que todos tengan una experiencia fluida. Estos límites se supervisan por transacción y por cliente e incluyen recursos como CPU Time, Memory, Query Runtime y Query Return Count, entre otros.</p>
            <p>Una transacción es una sola unidad de trabajo. Digamos que cuando actualice un registro que invoca un disparador, que invoca un flujo y se envía un correo electrónico, se definirá como una transacción.</p>
            <p>A diferencia de los métodos de base de datos donde podríamos detectar errores si y cuando ocurrieran, las excepciones de límite del gobernador (errores) no se pueden capturar usando bloques de código, y si una transacción de Apex golpea los límites del gobernador, todo el cambio se revierte y no se confirma nada en la base de datos.</p>

            <p>En términos de elaboración de café, la cantidad de café que puede preparar en un momento dado está limitada por el tamaño de su olla, la prensa francesa y el número de tazas que tiene disponibles. Así que si puede preparar 4 tazas de café a la vez, el proceso de hacer 4 tazas de café a la vez será una sola transacción y si intenta hacer 5 tazas de café, probablemente necesite eliminar los ingredientes adicionales antes de proceder para evitar derrames.</p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Evento</th>
                    <th>Límite</th>
                    <th>Método</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Total de estados de cuenta DML</td>
                    <td>150</td>
                    <td>limits.getLimitDmlStatements()</td>
                  </tr>
                  <tr>
                    <td>Total de registros procesados</td>
                    <td>10.000</td>
                    <td>limits.getLimitDmlRows</td>
                  </tr>
                  <tr>
                    <td>Total de consultas SOSL</td>
                    <td>20</td>
                    <td>limits.getLimitSOSLQueries()</td>
                  </tr>
                  <tr>
                    <td>Consultas SOQL totales</td>
                    <td>100</td>
                    <td>limits.getLimitQueries()</td>
                  </tr>
                  <tr>
                    <td>Tiempo máximo de CPU</td>
                    <td>10.000 ms (10 segundos)</td>
                    <td>limits.getLimitCpuTime()</td>
                  </tr>
                  <tr>
                    <td>Llamadas HTTP / Web Service</td>
                    <td>100</td>
                    <td>limits.getLimitcallouts()</td>
                  </tr>
                  <tr>
                    <td>Llamadas futuras máximas</td>
                    <td>50</td>
                    <td>limits.getLimitFutureCalls()</td>
                  </tr>
                  <tr>
                    <td>Tamaño total del montón</td>
                    <td>6 MB</td>
                    <td>limits.getLimitHeapSize()</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Podemos comprobar los límites actuales del gobernador utilizando los métodos para cada conjunto. Ejecutemos este código:</p>
            <pre><code>System.debug('Total DML Statements: ' + Limits.getLimitDmlStatements());
System.debug('Total Records Processed: ' + Limits.getLimitDmlRows());
System.debug('Total SOSL Queries: ' + Limits.getLimitSOSLQueries());
System.debug('Total SOQL Queries: ' + Limits.getLimitQueries());
System.debug('Max CPU Time: ' + Limits.getLimitCpuTime());
System.debug('HTTP / Web Service Limits: ' + Limits.getLimitCallouts());
System.debug('Max Future Callouts: ' + Limits.getLimitFutureCalls());
System.debug('Total Heap Size: ' + Limits.getLimitHeapSize());</code></pre>
            <p>To check for our current usage, we remove the <code>Limit</code> from our methods, so <code>Limits.getLimitDmlStatements()</code> becomes <code>Limits.getDmlStatements()</code>. Let's write a basic program and see it in action</p>
            <pre><code>List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();

for (Integer i = 1; i&lt;=10; i++){
	Contact con = new Contact();
	con.lastName = 'Test ' + i;
	finalList.add(con);
}

insert finalList;
System.debug(Limits.getDmlStatements());</code></pre>
            <p>The result for this code would be <code>1</code>, but we did process 10 contacts, right? It's because we are inserting multiple contacts using one DML statement. If we add the <code>con</code> object directly, we will see the number go
              much higher. Let's run this code:</p>
            <pre><code>for (Integer i = 1; i&lt;=10; i++){
	Contact con = new Contact();
	con.lastName = 'Test ' + i;
	insert con;
}
System.debug(Limits.getDmlStatements());</code></pre>

            <p>The result for this code is <code>10</code> because we ran the insert statement 10 times. This is the exact reason why we don't use DML statements inside a loop. What if we exceed the DML limit? Let's try to insert 200 objects inside a
              loop.</p>

            <pre><code>for (Integer i = 1; i&lt;=200; i++){
	Contact con = new Contact();
	con.lastName = 'Test ' + i;
	insert con;
}
System.debug(Limits.getDmlStatements());</code></pre>

            <p>Obtendrá el error:</p>
            <pre><code>Line: 4, Column: 1
System.LimitException: Too many DML statements: 151</code></pre>
            <p>Esto se debe a que en el momento en que superamos nuestros límites de gobernador, el programa se detiene y no hay manera de protegerse de este error, excepto escribir mejor código. Pero, ¿hay escenarios en los que podrías exceder los límites? Digamos que su empresa adquirió un nuevo negocio y ahora necesita insertar más de 100.000 contactos en la organización de Salesforce y editar su campo de país para que coincida con el sistema de nombres de la organización, y como desarrollador, está limitado a 10.000 registros que se procesan a la vez. Para esto, usamos algo llamado <em>Batch Apex</em></p>
            <h2>Ápice por lotes</h2>
            <p>Batch Apex se utiliza cuando estamos trabajando con enormes cantidades de datos que cruzan los límites del gobernador. Esto se logra dividiendo Batch Apex toda la consulta en subconjuntos más pequeños que funcionan en lotes más pequeños y no afectan el funcionamiento regular de la organización.</p>

            <p>En términos de elaboración de café, si puedes hacer 4 tazas de café a la vez, pero hay 9 personas que quieren beber tu café, tendrás que ejecutar el proceso tres veces (4+4+1) para obtener 9 tazas de café.</p>

            <p>To implement Batch Apex, we need to write a class that inherits from <code>Database.batchable</code> interface provided by Salesforce using the <code>implements</code> keyword available to Classes. The class must be <code>global</code>
              and must implement the <code>start()</code>, <code>execute()</code> and <code>finish()</code> methods.</p>
            <p>The <code>start()</code> method is all about Querying and collecting the datasets.
              The <code>execute()</code> method is all about working on the dataset.
              The <code>finish()</code> method is about what needs to be done after the records have been processes (Like send an email or create a task).</p>
            <p>Echemos un vistazo a la sintaxis y luego la desglosemos:</p>
            <pre><code>global class ClassName implements Database.Batchable&lt;sObject&gt; {
    global (Database.QueryLocator | Iterable&lt;sObject&gt;) start(Database.BatchableContext bc) {
    	//Query
    }
    global void execute(Database.BatchableContext bc, List&lt;P&gt; records){
    	//Process
    }
    global void finish(Database.BatchableContext bc){
	    //Post Processing
    }
}</code></pre>
            <p><strong>Clase</strong></p>
            <ul>
              <li>The classes and methods are defined <code>global</code> so they're available throughout Apex. This is different from public that is only available to the specific application.</li>
            </ul>
            <p><strong>inicio</strong></p>
            <ul>
              <li>El método start toma un Database.QueryLocator o un sObject que se puede iterar sobre</li>
              <li>Database.BatchableContext se utiliza para obtener valores como JobID()</li>
              <li>Devuelve una consulta</li>
            </ul>
            <p><strong>ejecutar</strong></p>
            <ul>
              <li>Database.BatchableContext define qué trabajo estamos ejecutando</li>
              <li>Lista<p>registros es la Lista devuelta desde<code>start()</code></p></li>
            </ul>
            <p><strong>acabado</strong></p>
            <ul>
              <li>Database.BatchableContext define el trabajo por lotes que estamos esperando para terminar</li>
            </ul>
            <p>Hagamos un poco de café antes de saltar a nuestra organización.</p>
            <pre><code>global class ClassName implements Database.Batchable&lt;sObject&gt; {
  global List&lt;items&gt; start(CoffeeBatchNumber batchNumber) {
    //Query
    List&lt;items&gt; coffeeItems = new List&lt;items&gt;();
    List&lt;items&gt;.add(arabicaCoffee);
    List&lt;items&gt;.add(frenchPress);
    List&lt;items&gt;.add(water);
    List&lt;items&gt;.add(boilingPot);
    List&lt;items&gt;.add(cup);
  }
  global void execute(CoffeeBatchNumber batchNumber, List&lt;items&gt; itemList){
    //Process
    tableTop = itemList;
    pot = boil(water);
    if (water == boiling){
      frenchPress = brew(coffee);
    }
  }
  global void finish(CoffeeBatchNumber batchNumber){
    //Post Processing
    cup = pour(frenchPress);
    drink;
  }
}</code> </pre>

            <p>Ahora escribamos algo de código real para entender mejor lo que está sucediendo. Primero escribamos nuestra clase que implementa Database.Batchable. Lo dejaremos en sObject para que no estemos restringidos por el objeto que queremos usar.</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{
}</code></pre>
            <p>Now, lets write our <code>start()</code> method that queries for all contacts that have the last name similar to <code>Test</code>:</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{

	global Database.QueryLocator start(Database.BatchableContext bc){
		return Database.getQueryLocator([SELECT ID, LastName from Contact WHERE LastName LIKE 'Test%']);
	}

}</code></pre>
            <p>Database.QueryLocator returns a recordset and is used with Batch Apex and takes an SOQL query as it's parameter, and can return <strong>50 Million</strong> records at a time. There is a similar method called <code>Database.Query</code>
              that we look into later in this chapter. Now let's manipulate these records in our <code>execute()</code> method:</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{

	global Database.QueryLocator start(Database.BatchableContext bc){
		return Database.getQueryLocator([SELECT ID, LastName FROM Contact WHERE LastName LIKE 'Test%']);
	}

	global void execute(Database.BatchableContext bc, List&lt;Contact&gt; conList){
		List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();
		for (Contact iterator: conList){
        iterator.firstName = iterator.LastName;
        finalList.add(iterator);
		}
		update finalList;
	}

}</code></pre>
            <p>In our execute method, we again call the same Database.BatchableContext job, and declare a new List of contacts that was returned by our <code>start()</code> method. While the first parameter stays the same, the second parameter is
              always what's returned by the <code>start()</code> method. If we ran a query on Accounts, our execute method would have <code>List&lt;Account&gt;</code> instead of <code>List&lt;Contact&gt;</code>. In the method, we iterate over what's
              returned by the start method and make the first name the same as last name, and add it to a list before updating our values. Let's write our <code>finish()</code> method now:</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{

	global Database.QueryLocator start(Database.BatchableContext bc){
		return Database.getQueryLocator([SELECT ID, LastName FROM Contact WHERE LastName LIKE 'Test%']);
	}

	global void execute(Database.BatchableContext bc, List&lt;Contact&gt; conList){
		List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();
		for (Contact iterator: conList){
			iterator.firstName = iterator.LastName;
      finalList.add(iterator);
		}
		update finalList;
	}

	global void finish(Database.BatchableContext bc){
		System.debug('Batch successfully executed');
	}

}</code></pre>
            <p>Now that we have written our Batch Class, we need to run it. To do that, we make a new object of the Batch class and use the <code>Database.execute()</code> method to run it, and assign it to an ID data type. The syntax for it is:</p>
            <pre><code>BatchClassName variableName = new BatchClassName();
ID variableName2 = Database.executeBatch(variableName);</code></pre>
            <p>Ahora ejecutemos nuestra clase por lotes:</p>
            <pre><code>ClassBatch newBatch = new ClassBatch();
ID batchId = Database.executeBatch(newBatch);</code></pre>
            <p>Opcionalmente, podemos pasar cuántos registros procesar en un solo lote como parámetro a nuestro método <code>Database.execute()</code>.</p>
            <pre><code>ClassBatch newBatch = new ClassBatch();
ID batchId = Database.executeBatch(newBatch, 100);</code></pre>
            <p>This will run on 100 records at a time, and the variable <code>batchId</code> contains the job ID of the process. Another great thing about using Batch Apex is every batch is a transaction, so every time a batch runs, it resets the
              Governor Limits, and since every run is a transaction, if a batch fails, it won't affect other batches.</p>

            <h2>Database.GetQueryLocator() y Database.Query()</h2>

            <p><code>Database.Query</code>le permite realizar consultas SOQL dinámicas en tiempo de ejecución y puede devolver hasta 50.000 registros.</p>
            <pre><code>String runningObj = 'Contact';
String queryString = 'SELECT ID, LastName FROM ' + runningObj + ' WHERE LastName LIKE 'Test' LIMIT 100';

Database.Query(queryString);</code></pre>
            <p><code>Database.GetQueryLocator</code>le permite ejecutar consultas SOQL y devolver hasta 50 millones de registros a la vez y se utiliza con el vértice por lotes.</p>
            <p>This does not mean that <code>Database.Query</code> cannot be used in Batch Apex. This is exactly what <code>iterable&lt;sObject&gt;</code> is used for:</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{


    global iterable&lt;sObject&gt; start(Database.BatchableContext bc){
        String qString = 'SELECT ID, LastName FROM Contact WHERE LastName = \'Test\'';
            return Database.query(qString);
    }

    global void execute(Database.BatchableContext bc, List&lt;Contact&gt; conList){
        List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();
        for (Contact iterator: conList){
            iterator.firstName = iterator.LastName;
            finalList.add(iterator);
        }
        update finalList;
    }

    global void finish(Database.BatchableContext bc){
        System.debug('Batch successfully executed');
    }

}</code></pre>
            <p>In the <code>start()</code> method, we now expect a <code>iterable&lt;sObject&gt;</code> return type and are using the <code>Database.query()</code> method to run our SOQL query and the rest of the code remains the same. Now, let's
              actually build a dynamic SOQL query.</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{

    global String queryString;

    public ClassBatch(String inputString){
        queryString = inputString;
    }

    global iterable&lt;sObject&gt; start(Database.BatchableContext bc){
        return Database.query(queryString);
    }

    global void execute(Database.BatchableContext bc, List&lt;Contact&gt; conList){
        List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();
        for (Contact iterator: conList){
            iterator.firstName = iterator.LastName;
            finalList.add(iterator);
        }
        update finalList;
    }

    global void finish(Database.BatchableContext bc){
        System.debug('Batch successfully executed');
    }

}</code></pre>
            <p>Una cosa a notar aquí es que tenemos un método con exactamente el mismo nombre que nuestra Clase. Esto se llama método de inicio, donde inicializamos una clase con parámetros. Toma un String como parámetro de entrada y lo asigna a una variable global interna que se utiliza para consultar. Escribamos la línea de ejecución:</p>
            <pre><code>String queryString = 'SELECT id, lastname FROM contact WHERE lastname = \'test\'';

ClassBatch batchVariable = new ClassBatch(queryString);
Database.executeBatch(batchVariable);</code></pre>
            <p>Here we first define our query as a string and then create a new object of the class and pass a parameter. This means that <code>batchVariable</code> is an object of the class with <code>queryString</code> as an init method. This code
              is 'dangerous' on a longer term because it only iterates over Contact objects, and it's extremely easy to forget that and then run into errors.</p>
            <h1>Resumen</h1>
            <ul>
              <li>Se ponen límites al gobernador para garantizar que haya suficientes recursos informáticos disponibles para todos.</li>
              <li>Batch Apex has three methods, <code>start()</code>, <code>execute()</code> and <code>finish()</code> that must be defined.</li>
              <li>Puede que Batch Apex no se ejecute siempre inmediatamente, pero se ejecutará cuando haya suficientes recursos informáticos disponibles.</li>
            </ul>
            <a href="15.html" class="global-button">Día 15: Prueba de ápice por lotes</a>
          </div>
        </article>

      </main>
      <footer class="footer-section global-footer">
        <div class="footer-copyright">© <a href="http://harshdeephura.com" target="_blank">Harshdeep Singh Hura</a>.<br>Todos los derechos reservados.</div>
      </footer>
    </div>
  </div>




  <script src="../assets/js/global.js"></script>




</body></html>

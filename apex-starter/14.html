<html lang="fr-FR"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Cours de démarrage Apex | Admin2Dev</title>
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@500&amp;family=Spartan:wght@500;600;700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Muli:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="../assets/css/stylesheet.css">

  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

  <meta property="og:site_name" content="Admin2Dev">

  <meta property="og:title" content="Governor Limits and Batch Apex"> <!-- Content Title-->
  <meta property="og:description" content="Learn to write Batch Apex classes and what Governor Limits are in Salesforce"> <!-- Content Description -->
  <meta property="og:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:url" content="https://admin2dev.com/">


  <meta property="article:author" content="https://twitter.com/kinngh">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Governor Limits and Batch Apex"> <!-- Twitter Title -->
  <meta name="twitter:description" content="Learn to write Batch Apex classes and what Governor Limits are in Salesforce"> <!-- Twitter description -->
  <meta name="twitter:url" content="https://admin2dev.com">
  <meta name="twitter:label1" content="Written by">
  <meta name="twitter:data1" content="Harshdeep Singh Hura">
  <meta name="twitter:label2" content="Filed under">
  <meta name="twitter:data2" content="Apex Tutorials">
  <meta name="twitter:site" content="@kinngh">
  <meta name="twitter:creator" content="@kinngh">
  <meta name="twitter:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-112097931-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-112097931-2');
</script><script async src="https://hm-ackee.herokuapp.com/tracker.js" data-ackee-server="https://hm-ackee.herokuapp.com" data-ackee-domain-id="e6e2d901-0aed-483b-bbdf-074952248f20"></script>

</head>

<body id="myBody" class="global-hash-post-card-amber global-hash-post-card-apricot global-hash-post-card-aqua global-hash-post-card-coral global-hash-post-card-cream global-hash-post-card-green global-hash-post-card-purple global-hash-post-card-raspberry global-hash-post-card-sky is-loaded">
  <div class="global-wrap">
    <div class="global-content">
      <header class="header-section">
        <div class="header-wrap">
          <div class="header-logo">
            <a href="../index.html" class="is-image">
              <img src="../images/logo.png" alt="Admin2Dev">
            </a>
          </div>
          <div class="header-nav">
            <input id="toggle" class="header-checkbox" type="checkbox">
            <label class="header-toggle" for="toggle">
              <span>
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
              </span>
            </label>
            <nav>
              <ul>
                <li><a href="../index.html">Accueil</a></li>
                <li><a href="../learn/index.html">Apprendre</a></li>
<li><a href="../tools/index.html">Outils</a></li>
                 <li><a href="../sponsor/index.html">Commanditaire</a></li>
                <li class="header-nav-dropdown">
                  <svg role="img" viewBox="0 0 20 4" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 4A2 2 0 102.001.001 2 2 0 002 4zm8 0a2 2 0 10.001-3.999A2 2 0 0010 4zm8 0a2 2 0 10.001-3.999A2 2 0 0018 4z"></path></svg>
                  <ul>
                    <li><a href="../about/index.html">À propos</a></li><li><a href="../terms.html">Conditions d'utilisation</a></li>
                    <li><a href="../privacy.html">Politique de confidentialité</a></li>
                  </ul>
                </li>
              </ul>
              <ul>
                <li class="signup global-button"><a href="https://discord.gg/5ndr5F8" target="_blank">Rejoignez la communauté</a></li>
                <li class="signin"><a onclick="darkMode()" id="darkModeText">Mode sombre</a></li>
              </ul>
            </nav>
          </div>
        </div>
      </header>
      <main class="global-main">
        <article class="post-section">
          <div class="post-header item is-hero is-page is-first post no-image page">
            <div class="item-container global-color">
              <div class="item-content">
                <h2 class="item-title">Limites de gouverneur et apex de lot</h2>
              </div>
            </div>
          </div>
          <div class="post-content">
            <h2>Limites du gouverneur</h2>
            <p>Salesforce étant l'environnement multilocataire qu'il est, doit s'assurer que les ressources sont disponibles pour tout le monde afin de s'assurer que tout le monde a une expérience fluide. Ces limites sont surveillées par transaction et par client et comprennent des ressources telles que le temps CPU, la mémoire, l'exécution des requêtes et le nombre de retours de requêtes, entre autres.</p>
            <p>Une transaction est une seule unité de travail. Supposons que lorsque vous mettez à jour un enregistrement qui invoque un déclencheur, qui invoque un flux et qu'un e-mail est envoyé, sera défini comme une seule transaction.</p>
            <p>Contrairement aux méthodes de base de données où nous pourrions détecter les erreurs si et quand elles se produisaient, les exceptions de limite de gouverneur (erreurs) ne peuvent pas être détectées à l'aide de blocs de code, et si une transaction Apex atteint les limites de gouverneur, la modification entière est annulée et rien n'est validé dans la base de données.</p>

            <p>En termes de café, la quantité de café que vous pouvez brasser à un moment donné est limitée par la taille de votre pot, de votre presse française et le nombre de tasses que vous avez à disposition. Donc, si vous pouvez infuser 4 tasses de café à la fois, le processus de fabrication de 4 tasses de café à la fois sera une seule transaction et si vous essayez de faire 5 tasses de café, vous devez probablement enlever les ingrédients supplémentaires avant de procéder pour éviter les déversements.</p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Événement</th>
                    <th>Limite</th>
                    <th>Méthode</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Total des relevés DML</td>
                    <td>150</td>
                    <td>limits.getLimitDmlStatements()</td>
                  </tr>
                  <tr>
                    <td>Total des dossiers traités</td>
                    <td>10 000</td>
                    <td>limits.getLimitDmlRows</td>
                  </tr>
                  <tr>
                    <td>Total des requêtes SOSL</td>
                    <td>20</td>
                    <td>limits.getLimitSOSLQueries()</td>
                  </tr>
                  <tr>
                    <td>Total des requêtes SOQL</td>
                    <td>100</td>
                    <td>limits.getLimitQueries()</td>
                  </tr>
                  <tr>
                    <td>Temps CPU maximal</td>
                    <td>10 000 ms (10 secondes)</td>
                    <td>limits.getLimitCpuTime()</td>
                  </tr>
                  <tr>
                    <td>Appels HTTP / Web Service</td>
                    <td>100</td>
                    <td>limits.getLimitcallouts()</td>
                  </tr>
                  <tr>
                    <td>Max Future Callouts</td>
                    <td>50</td>
                    <td>limits.getLimitFutureCalls()</td>
                  </tr>
                  <tr>
                    <td>Taille totale du tas</td>
                    <td>6 Mo</td>
                    <td>limits.getLimitHeapSize()</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Nous pouvons vérifier les limites de gouverneur actuelles en utilisant les méthodes pour chaque ensemble. exécutons ce code :</p>
            <pre><code>System.debug('Total DML Statements: ' + Limits.getLimitDmlStatements());
System.debug('Total Records Processed: ' + Limits.getLimitDmlRows());
System.debug('Total SOSL Queries: ' + Limits.getLimitSOSLQueries());
System.debug('Total SOQL Queries: ' + Limits.getLimitQueries());
System.debug('Max CPU Time: ' + Limits.getLimitCpuTime());
System.debug('HTTP / Web Service Limits: ' + Limits.getLimitCallouts());
System.debug('Max Future Callouts: ' + Limits.getLimitFutureCalls());
System.debug('Total Heap Size: ' + Limits.getLimitHeapSize());</code></pre>
            <p>To check for our current usage, we remove the <code>Limit</code> from our methods, so <code>Limits.getLimitDmlStatements()</code> becomes <code>Limits.getDmlStatements()</code>. Let's write a basic program and see it in action</p>
            <pre><code>List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();

for (Integer i = 1; i&lt;=10; i++){
	Contact con = new Contact();
	con.lastName = 'Test ' + i;
	finalList.add(con);
}

insert finalList;
System.debug(Limits.getDmlStatements());</code></pre>
            <p>The result for this code would be <code>1</code>, but we did process 10 contacts, right? It's because we are inserting multiple contacts using one DML statement. If we add the <code>con</code> object directly, we will see the number go
              much higher. Let's run this code:</p>
            <pre><code>for (Integer i = 1; i&lt;=10; i++){
	Contact con = new Contact();
	con.lastName = 'Test ' + i;
	insert con;
}
System.debug(Limits.getDmlStatements());</code></pre>

            <p>The result for this code is <code>10</code> because we ran the insert statement 10 times. This is the exact reason why we don't use DML statements inside a loop. What if we exceed the DML limit? Let's try to insert 200 objects inside a
              loop.</p>

            <pre><code>for (Integer i = 1; i&lt;=200; i++){
	Contact con = new Contact();
	con.lastName = 'Test ' + i;
	insert con;
}
System.debug(Limits.getDmlStatements());</code></pre>

            <p>Vous obtiendrez l'erreur :</p>
            <pre><code>Line: 4, Column: 1
System.LimitException: Too many DML statements: 151</code></pre>
            <p>C'est parce que dès que nous dépassons nos limites de gouverneur, le programme s'arrête et il n'y a aucun moyen de se protéger contre cette erreur, sauf pour écrire un meilleur code. Mais il existe des scénarios où vous pourriez dépasser les limites ? Supposons que votre entreprise ait acquis une nouvelle entreprise et qu'elle doive maintenant insérer plus de 100 000 contacts dans l'organisation Salesforce et modifier son champ pays pour correspondre au système de nommage de l'organisation, et en tant que développeur, vous êtes limité à 10 000 enregistrements en cours de traitement à la fois. Pour cela, nous utilisons quelque chose appelé <em>Batch Apex</em></p>
            <h2>Lot Apex</h2>
            <p>Batch Apex est utilisé lorsque nous travaillons avec d'énormes quantités de données qui dépassent les limites du gouverneur. Ceci est réalisé en Batch Apex décomposant l'ensemble de la requête en sous-ensembles plus petits qui fonctionnent en petits lots et n'affectent pas le fonctionnement régulier de l'organisation.</p>

            <p>En termes de café, si vous pouvez faire 4 tasses de café à la fois, mais qu'il y a 9 personnes qui veulent boire votre café, vous devrez exécuter le processus trois fois (4+4+1) pour obtenir 9 tasses de café.</p>

            <p>To implement Batch Apex, we need to write a class that inherits from <code>Database.batchable</code> interface provided by Salesforce using the <code>implements</code> keyword available to Classes. The class must be <code>global</code>
              and must implement the <code>start()</code>, <code>execute()</code> and <code>finish()</code> methods.</p>
            <p>The <code>start()</code> method is all about Querying and collecting the datasets.
              The <code>execute()</code> method is all about working on the dataset.
              The <code>finish()</code> method is about what needs to be done after the records have been processes (Like send an email or create a task).</p>
            <p>Examinons la syntaxe, puis décomposons-la :</p>
            <pre><code>global class ClassName implements Database.Batchable&lt;sObject&gt; {
    global (Database.QueryLocator | Iterable&lt;sObject&gt;) start(Database.BatchableContext bc) {
    	//Query
    }
    global void execute(Database.BatchableContext bc, List&lt;P&gt; records){
    	//Process
    }
    global void finish(Database.BatchableContext bc){
	    //Post Processing
    }
}</code></pre>
            <p><strong>Classe</strong></p>
            <ul>
              <li>The classes and methods are defined <code>global</code> so they're available throughout Apex. This is different from public that is only available to the specific application.</li>
            </ul>
            <p><strong>commencer</strong></p>
            <ul>
              <li>La méthode de démarrage prend soit un Database.QueryLocator, soit un sObject qui peut être itéré sur</li>
              <li>Database.BatchableContext est utilisé pour obtenir des valeurs comme JobID()</li>
              <li>Retourne une requête</li>
            </ul>
            <p><strong>exécuter</strong></p>
            <ul>
              <li>Database.BatchableContext définit quel travail exécutons-nous ?</li>
              <li>Liste<p>enregistrements est la liste renvoyée par<code>start()</code></p></li>
            </ul>
            <p><strong>finition</strong></p>
            <ul>
              <li>Database.BatchableContext définit le travail par lots que nous attendons de terminer</li>
            </ul>
            <p>Faisons un café avant de sauter sur notre organisation.</p>
            <pre><code>global class ClassName implements Database.Batchable&lt;sObject&gt; {
  global List&lt;items&gt; start(CoffeeBatchNumber batchNumber) {
    //Query
    List&lt;items&gt; coffeeItems = new List&lt;items&gt;();
    List&lt;items&gt;.add(arabicaCoffee);
    List&lt;items&gt;.add(frenchPress);
    List&lt;items&gt;.add(water);
    List&lt;items&gt;.add(boilingPot);
    List&lt;items&gt;.add(cup);
  }
  global void execute(CoffeeBatchNumber batchNumber, List&lt;items&gt; itemList){
    //Process
    tableTop = itemList;
    pot = boil(water);
    if (water == boiling){
      frenchPress = brew(coffee);
    }
  }
  global void finish(CoffeeBatchNumber batchNumber){
    //Post Processing
    cup = pour(frenchPress);
    drink;
  }
}</code> </pre>

            <p>Maintenant, écrivons du code réel pour mieux comprendre ce qui se passe. Tout d'abord, écrivons notre classe qui implémente Database.Batchable. Nous le laisserons sur sObject afin de ne pas être limités par l'objet que nous voulons utiliser.</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{
}</code></pre>
            <p>Now, lets write our <code>start()</code> method that queries for all contacts that have the last name similar to <code>Test</code>:</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{

	global Database.QueryLocator start(Database.BatchableContext bc){
		return Database.getQueryLocator([SELECT ID, LastName from Contact WHERE LastName LIKE 'Test%']);
	}

}</code></pre>
            <p>Database.QueryLocator returns a recordset and is used with Batch Apex and takes an SOQL query as it's parameter, and can return <strong>50 Million</strong> records at a time. There is a similar method called <code>Database.Query</code>
              that we look into later in this chapter. Now let's manipulate these records in our <code>execute()</code> method:</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{

	global Database.QueryLocator start(Database.BatchableContext bc){
		return Database.getQueryLocator([SELECT ID, LastName FROM Contact WHERE LastName LIKE 'Test%']);
	}

	global void execute(Database.BatchableContext bc, List&lt;Contact&gt; conList){
		List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();
		for (Contact iterator: conList){
        iterator.firstName = iterator.LastName;
        finalList.add(iterator);
		}
		update finalList;
	}

}</code></pre>
            <p>In our execute method, we again call the same Database.BatchableContext job, and declare a new List of contacts that was returned by our <code>start()</code> method. While the first parameter stays the same, the second parameter is
              always what's returned by the <code>start()</code> method. If we ran a query on Accounts, our execute method would have <code>List&lt;Account&gt;</code> instead of <code>List&lt;Contact&gt;</code>. In the method, we iterate over what's
              returned by the start method and make the first name the same as last name, and add it to a list before updating our values. Let's write our <code>finish()</code> method now:</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{

	global Database.QueryLocator start(Database.BatchableContext bc){
		return Database.getQueryLocator([SELECT ID, LastName FROM Contact WHERE LastName LIKE 'Test%']);
	}

	global void execute(Database.BatchableContext bc, List&lt;Contact&gt; conList){
		List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();
		for (Contact iterator: conList){
			iterator.firstName = iterator.LastName;
      finalList.add(iterator);
		}
		update finalList;
	}

	global void finish(Database.BatchableContext bc){
		System.debug('Batch successfully executed');
	}

}</code></pre>
            <p>Now that we have written our Batch Class, we need to run it. To do that, we make a new object of the Batch class and use the <code>Database.execute()</code> method to run it, and assign it to an ID data type. The syntax for it is:</p>
            <pre><code>BatchClassName variableName = new BatchClassName();
ID variableName2 = Database.executeBatch(variableName);</code></pre>
            <p>Maintenant, dirigeons notre classe de lots :</p>
            <pre><code>ClassBatch newBatch = new ClassBatch();
ID batchId = Database.executeBatch(newBatch);</code></pre>
            <p>En option, nous pouvons passer le nombre d'enregistrements à traiter dans un seul lot en paramètre à notre méthode <code>Database.execute()</code>.</p>
            <pre><code>ClassBatch newBatch = new ClassBatch();
ID batchId = Database.executeBatch(newBatch, 100);</code></pre>
            <p>This will run on 100 records at a time, and the variable <code>batchId</code> contains the job ID of the process. Another great thing about using Batch Apex is every batch is a transaction, so every time a batch runs, it resets the
              Governor Limits, and since every run is a transaction, if a batch fails, it won't affect other batches.</p>

            <h2>Database.GetQueryLocator() et Database.Query()</h2>

            <p><code>Database.Query</code>vous permet de faire des requêtes SOQL dynamiques à l'exécution et peut renvoyer jusqu'à 50 000 enregistrements.</p>
            <pre><code>String runningObj = 'Contact';
String queryString = 'SELECT ID, LastName FROM ' + runningObj + ' WHERE LastName LIKE 'Test' LIMIT 100';

Database.Query(queryString);</code></pre>
            <p><code>Database.GetQueryLocator</code>vous permet d'exécuter des requêtes SOQL et de renvoyer jusqu'à 50 millions d'enregistrements à la fois et est utilisé avec l'apex par lots.</p>
            <p>This does not mean that <code>Database.Query</code> cannot be used in Batch Apex. This is exactly what <code>iterable&lt;sObject&gt;</code> is used for:</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{


    global iterable&lt;sObject&gt; start(Database.BatchableContext bc){
        String qString = 'SELECT ID, LastName FROM Contact WHERE LastName = \'Test\'';
            return Database.query(qString);
    }

    global void execute(Database.BatchableContext bc, List&lt;Contact&gt; conList){
        List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();
        for (Contact iterator: conList){
            iterator.firstName = iterator.LastName;
            finalList.add(iterator);
        }
        update finalList;
    }

    global void finish(Database.BatchableContext bc){
        System.debug('Batch successfully executed');
    }

}</code></pre>
            <p>In the <code>start()</code> method, we now expect a <code>iterable&lt;sObject&gt;</code> return type and are using the <code>Database.query()</code> method to run our SOQL query and the rest of the code remains the same. Now, let's
              actually build a dynamic SOQL query.</p>
            <pre><code>global class ClassBatch implements Database.Batchable&lt;sObject&gt;{

    global String queryString;

    public ClassBatch(String inputString){
        queryString = inputString;
    }

    global iterable&lt;sObject&gt; start(Database.BatchableContext bc){
        return Database.query(queryString);
    }

    global void execute(Database.BatchableContext bc, List&lt;Contact&gt; conList){
        List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();
        for (Contact iterator: conList){
            iterator.firstName = iterator.LastName;
            finalList.add(iterator);
        }
        update finalList;
    }

    global void finish(Database.BatchableContext bc){
        System.debug('Batch successfully executed');
    }

}</code></pre>
            <p>Une chose à remarquer ici, c'est que nous avons une méthode exactement du même nom que notre classe. C'est ce qu'on appelle une méthode d'initialisation, où nous initialisons une classe avec des paramètres. Il prend une chaîne comme paramètre d'entrée et l'affecte à une variable globale interne qui est utilisée pour l'interrogation. Apprenons la ligne d'exécution :</p>
            <pre><code>String queryString = 'SELECT id, lastname FROM contact WHERE lastname = \'test\'';

ClassBatch batchVariable = new ClassBatch(queryString);
Database.executeBatch(batchVariable);</code></pre>
            <p>Here we first define our query as a string and then create a new object of the class and pass a parameter. This means that <code>batchVariable</code> is an object of the class with <code>queryString</code> as an init method. This code
              is 'dangerous' on a longer term because it only iterates over Contact objects, and it's extremely easy to forget that and then run into errors.</p>
            <h1>Résumé</h1>
            <ul>
              <li>Des limites de gouverneur sont mises en place pour s'assurer qu'il y a suffisamment de ressources informatiques disponibles pour tout le monde.</li>
              <li>Batch Apex has three methods, <code>start()</code>, <code>execute()</code> and <code>finish()</code> that must be defined.</li>
              <li>L'Apex par lots peut ne pas toujours s'exécuter immédiatement, mais s'exécutera lorsque suffisamment de ressources informatiques seront disponibles.</li>
            </ul>
            <a href="15.html" class="global-button">Jour 15 : Test d'apex par lots</a>
          </div>
        </article>

      </main>
      <footer class="footer-section global-footer">
        <div class="footer-copyright">© <a href="http://harshdeephura.com" target="_blank">Harshdeep Singh Hura</a>.<br>Tous droits réservés.</div>
      </footer>
    </div>
  </div>




  <script src="../assets/js/global.js"></script>




</body></html>

<html lang="es-ES"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Curso Apex Starter | Admin2Dev</title>
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@500&amp;family=Spartan:wght@500;600;700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Muli:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="../assets/css/stylesheet.css">

  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

  <meta property="og:site_name" content="Admin2Dev">

  <meta property="og:title" content="Apex Triggers and Order of Execution"> <!-- Content Title-->
  <meta property="og:description" content="Learn what are Apex Triggers and the Order of Execution in Salesforce"> <!-- Content Description -->
  <meta property="og:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:url" content="https://admin2dev.com/">


  <meta property="article:author" content="https://twitter.com/kinngh">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Apex Triggers and Order of Execution"> <!-- Twitter Title -->
  <meta name="twitter:description" content="Learn what are Apex Triggers and the Order of Execution in Salesforce"> <!-- Twitter description -->
  <meta name="twitter:url" content="https://admin2dev.com">
  <meta name="twitter:label1" content="Written by">
  <meta name="twitter:data1" content="Harshdeep Singh Hura">
  <meta name="twitter:label2" content="Filed under">
  <meta name="twitter:data2" content="Apex Tutorials">
  <meta name="twitter:site" content="@kinngh">
  <meta name="twitter:creator" content="@kinngh">
  <meta name="twitter:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-112097931-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-112097931-2');
</script><script async="" src="https://hm-ackee.herokuapp.com/tracker.js" data-ackee-server="https://hm-ackee.herokuapp.com" data-ackee-domain-id="b76d74a9-da14-46a7-b30a-596c57329e5b"></script>

</head>

<body id="myBody" class="global-hash-post-card-amber global-hash-post-card-apricot global-hash-post-card-aqua global-hash-post-card-coral global-hash-post-card-cream global-hash-post-card-green global-hash-post-card-purple global-hash-post-card-raspberry global-hash-post-card-sky global-hash-dark-version is-loaded">
  <div class="global-wrap">
    <div class="global-content">
      <header class="header-section">
        <div class="header-wrap">
          <div class="header-logo">
            <a href="../index.html" class="is-image">
              <img src="../images/logo.png" alt="Admin2Dev">
            </a>
          </div>
          <div class="header-nav">
            <input id="toggle" class="header-checkbox" type="checkbox">
            <label class="header-toggle" for="toggle">
              <span>
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
              </span>
            </label>
            <nav>
              <ul>
                <li><a href="../index.html">Inicio</a></li>
                <li><a href="../learn/index.html">Aprender</a></li>
<li><a href="../tools/index.html">Herramientas</a></li>
                 <li><a href="../sponsor/index.html">Patrocinador</a></li>
                <li class="header-nav-dropdown">
                  <svg role="img" viewBox="0 0 20 4" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 4A2 2 0 102.001.001 2 2 0 002 4zm8 0a2 2 0 10.001-3.999A2 2 0 0010 4zm8 0a2 2 0 10.001-3.999A2 2 0 0018 4z"></path></svg>
                  <ul>
                    <li><a href="../about/index.html">Acerca de</a></li><li><a href="../terms.html">Condiciones del servicio</a></li>
                    <li><a href="../privacy.html">Política de privacidad</a></li>
                  </ul>
                </li>
              </ul>
              <ul>
                <li class="signup global-button"><a href="https://discord.gg/5ndr5F8" target="_blank">Únete a la comunidad</a></li>
                <li class="signin"><a onclick="darkMode()" id="darkModeText">Modo de luz</a></li>
              </ul>
            </nav>
          </div>
        </div>
      </header>
      <main class="global-main">
        <article class="post-section">
          <div class="post-header item is-hero is-page is-first post no-image page">
            <div class="item-container global-color">
              <div class="item-content">
                <h2 class="item-title">Disparadores de ápice y orden de ejecución</h2>
              </div>
            </div>
          </div>
          <div class="post-content">

            <p>Cuando un evento tiene lugar en Salesforce, sigue un <em>orden de ejecución </em>(descrito más adelante en este capítulo) que llama a los desencadenadores en varios puntos y es una de las muchas maneras de invocar el código Apex. Si vemos desencadenantes en un proceso de elaboración de café, es hacer un conjunto de acciones cuando ocurren eventos específicos. Por ejemplo, cuando ponemos agua en la olla a hervir, por lo general esperamos a que salga vapor antes de verterlo, como si algo en el cerebro <em>si sale vapor, vierte agua</em>.</p>
            <p>Para escribir un disparador, seleccionamos Archivo &gt; Nuevo &gt; Disparador Apex (en lugar de Clase Apex) en la consola del desarrollador. La sintaxis para escribir un disparador es:</p>
            <pre><code>trigger TriggerName on Object(triggerEvents){
    //code
}
</code></pre>
            <ul>
              <li><code>trigger</code>palabra clave para inicializar un disparador.</li>
              <li><code>TriggerName</code>es el nombre asignado a este disparador.</li>
              <li><code>on</code>palabra clave que define en qué objeto lo estamos ejecutando.</li>
              <li><code>Object</code>es el nombre del objeto en el que se ejecutará el disparador.</li>
              <li><code>triggerEvents</code> defines <em>when</em> and on <em>what event</em> will the trigger run using the keywords <code>before</code> or <code>after</code> followed by
                standard DML operations like <code>insert</code>. Multiple trigger events are separated using a <code>,</code>.</li>
            </ul>
            <p>Hay dos métodos clave de clase Trigger para saber:</p>
            <ul>
              <li><code>Trigger.new</code>contiene todos los valores que son nuevos en el objeto.</li>
              <li><code>Trigger.old</code>contiene todos los valores que estaban en el objeto antes de ser actualizado.</li>
            </ul>
            <p>A real-life example is you take a cup. First you fill it with water, then you pour the water out and add milk in it. <code>Trigger.new</code> will return the value
              <code>milk</code>, and <code>Trigger.old</code> will return the value <code>water</code> when run on the cup. Let’s write a simple trigger on Contact object that checks if the First Name is empty, and fills it as ‘John’ if it is empty.
            </p>
            <pre><code>trigger FirstNamer on Contact(before insert){
    List&lt;Contact&gt; con = Trigger.new;

    for (Contact iterator: con){

        if(iterator.FirstName == null){
            iterator.FirstName = 'John';
        }
    }

}
</code></pre>
            <p>Now let’s head over to our org and make 2 new entries in the Contact object. The first entry should have First and Last Names and the second should have only a Last Name.
              You will notice the second record where no First name was specified, the value <code>John</code> has now been filled instead. Let’s write a trigger that makes use of <code>Trigger.old</code>.</p>
            <p>This new trigger runs on the Contact object and if the old First Name of a Contact was <code>John</code>, we want to replace whatever new value the user has put in with
              <code>Smith</code> instead. So if a person with the name <code>John Cool</code> existed in the database and a user tries to update the first name from <code>John</code> to anything else, the value gets saved as <code>Smith</code>
              instead.</p>
            <pre><code>trigger FirstName on Contact(after update){

    List&lt;Contact&gt; con = Trigger.old;
    List&lt;ID&gt; conId = new List&lt;ID&gt;();
    List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();

    for (Contact iterator: con){
        if(iterator.FirstName == 'John'){
            conId.add(iterator.Id);
        }
    }

    List&lt;Contact&gt; updateList = [SELECT ID, FirstName FROM Contact WHERE ID = :conId];

    for (Contact iterator: updateList){
        iterator.FirstName = 'Smith';
        finalList.add(iterator);
    }

    update finalList;

}
</code></pre>
            <p>Si bien esto parece mucho código, es fácil de entender con un desglose:</p>
            <ul>
              <li>First we make an <code>after update</code> trigger. The reason behind this is <code>Trigger.old</code> doesn’t exist until a change has occurred in the values.</li>
              <li>We make 3 lists. <code>con</code> to hold old values. <code>conId</code> to hold the IDs of values we need to update. <code>finalList</code> to update the values.</li>
              <li>The for loop that runs on <code>con</code> goes over the old values and searches for contacts where the First Name was <code>John</code> and stores just he ID in
                <code>conId</code> list.</li>
              <li>Ahora ejecutamos una consulta SOQL para obtener todos los registros con ID coincidentes que existen actualmente en nuestra base de datos.</li>
              <li>El bucle for recorre los partidos y cambia su nombre a <code>Smith Cool</code>.</li>
            </ul>
            <p>La primera pregunta que surge es <em>Cuándo usar los desencadenantes antes y después</em>. Para esto, primero necesitamos entender la <em>Orden de Ejecución</em>.</p>
            <hr>
            <h2>Orden de ejecución</h2>
            <p>Al igual que el proceso de elaboración de café que sigue una secuencia específica, el Orden de Ejecución es una secuencia de eventos que ocurren cuando se produce una operación de inserción, actualización o actualización en Salesforce. Todos los eventos en el orden de ejecución deben ejecutarse correctamente antes de que los datos se confirmen en la base de datos y si hay un error, todos los cambios se revierten y no se ejecutan más eventos. A continuación se muestra el orden de ejecución en orden de ocurrencia tomado directamente de la documentación de Salesforce disponible <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_order_of_execution.htm" target="_blank">aquí</a></p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Secuencia</th>
                    <th>Evento</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>Carga el registro original de la base de datos o inicializa el registro para una instrucción upsert.</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Carga los nuevos valores de campo de registro de la solicitud y sobrescribe los valores antiguos. *</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Ejecuta flujos que realizan actualizaciones antes de guardar.</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Ejecuta todo antes de los disparadores.</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Ejecuta la mayoría de los pasos de validación del sistema de nuevo, como verificar que todos los campos obligatorios tengan un valor no nulo, y ejecuta cualquier regla de validación definida por el usuario. La única validación del sistema que Salesforce no ejecuta por segunda vez (cuando la solicitud proviene de una página de edición de interfaz de usuario estándar) es la aplicación de reglas específicas del diseño.</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Ejecuta reglas duplicadas. Si la regla duplicada identifica el registro como un duplicado y utiliza la acción de bloque, el registro no se guarda y no se toman más pasos, como después de los disparadores y las reglas de flujo de trabajo.</td>
                  </tr>
                  <tr>
                    <td>7</td>
                    <td>Guarda el registro en la base de datos, pero aún no se confirma.</td>
                  </tr>
                  <tr>
                    <td>8</td>
                    <td>Ejecuta todo después de los disparadores.</td>
                  </tr>
                  <tr>
                    <td>9</td>
                    <td>Ejecuta reglas de asignación.</td>
                  </tr>
                  <tr>
                    <td>10</td>
                    <td>Ejecuta reglas de respuesta automática.</td>
                  </tr>
                  <tr>
                    <td>11</td>
                    <td>Ejecuta reglas de flujo de trabajo.</td>
                  </tr>
                  <tr>
                    <td>12</td>
                    <td>Si hay actualizaciones de campos de flujo de trabajo, actualice el registro de nuevo.</td>
                  </tr>
                  <tr>
                    <td>13</td>
                    <td>Si el registro se actualizó con actualizaciones de campo de flujo de trabajo, se activa antes de que se active la actualización y después de que la actualización se active una vez más (y solo una vez más), además de las validaciones estándar. Las reglas de validación personalizadas, los flujos, las reglas duplicadas, los procesos y las reglas de escalada no se vuelven a ejecutar.</td>
                  </tr>
                  <tr>
                    <td>14</td>
                    <td>Ejecuta procesos y flujos iniciados a través de procesos y acciones de flujo de trabajo de activación de flujo. Cuando un proceso o flujo ejecuta una operación DML, el registro afectado pasa por el procedimiento de guardado.</td>
                  </tr>
                  <tr>
                    <td>15</td>
                    <td>Ejecuta reglas de escalada.</td>
                  </tr>
                  <tr>
                    <td>16</td>
                    <td>Ejecuta reglas de derechos.</td>
                  </tr>
                  <tr>
                    <td>17</td>
                    <td>Si el registro contiene un campo de resumen acumulativo o es parte de un flujo de trabajo entre objetos, realiza cálculos y actualiza el campo de resumen acumulativo en el registro principal. El registro principal pasa por el procedimiento de guardado.</td>
                  </tr>
                  <tr>
                    <td>18</td>
                    <td>Si el registro principal se actualiza y un registro de abuelos contiene un campo de resumen acumulativo o es parte de un flujo de trabajo entre objetos, realiza cálculos y actualiza el campo de resumen acumulativo en el registro de abuelos. El registro de los abuelos pasa por el procedimiento de guardado.</td>
                  </tr>
                  <tr>
                    <td>19</td>
                    <td>Ejecuta la evaluación del uso compartido basada en criterios.</td>
                  </tr>
                  <tr>
                    <td>20</td>
                    <td>Confirma todas las operaciones DML a la base de datos.</td>
                  </tr>
                  <tr>
                    <td>21</td>
                    <td>Ejecuta la lógica posterior a la confirmación, como el envío de correo electrónico.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Continuación en la Secuencia 2:</p>
            <ul>
              <li>Si la solicitud vino de una página de edición de interfaz de usuario estándar, Salesforce ejecuta la validación del sistema para comprobar el registro:<ul>
                  <li>Cumplimiento de las reglas específicas del diseño</li>
                  <li>Valores requeridos a nivel de diseño y nivel de definición de campo</li>
                  <li>Formatos de campo válidos</li>
                  <li>Longitud máxima del campo</li>
                </ul>
              </li>
              <li>Cuando la solicitud proviene de otras fuentes, como una aplicación Apex o una llamada a la API SOAP, Salesforce valida solo las claves foráneas. Antes de ejecutar un disparador, Salesforce verifica que ninguna clave foránea personalizada no haga referencia al objeto en sí.</li>
              <li>Salesforce ejecuta reglas de validación definidas por el usuario si se crearon elementos multilínea, como elementos de línea de cotización y elementos de línea de oportunidad.</li>
            </ul>
            <p>Toda la Orden de Ejecución se puede dividir en 3 tablas más pequeñas que son más fáciles de entender:</p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Secuencia</th>
                    <th>Evento</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>Se carga el registro original O se inicializan nuevos registros</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Los valores de campo se cargan en sObjects</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Antes de que se ejecuten los disparadores</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Las reglas de validación del sistema se ejecutan de nuevo y las reglas de validación personalizadas se comprueban</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>1</td>
                    <td>Se ejecutan reglas duplicadas</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>El registro se guarda pero no se confirma</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Después de ejecutar los disparadores</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Las reglas de asignación se ejecutan</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Las reglas de respuesta automática se ejecutan</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Antes de los disparadores, las reglas de validación del sistema y después de que los disparadores se ejecuten debido a las actualizaciones de campos de flujo de trabajo</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>1</td>
                    <td>Los procesos se ejecutan</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Las reglas de escalada se ejecutan</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Las reglas de autorización se ejecutan</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Se actualizan los campos de resumen acumulativo y los campos de fórmula de objetos cruzados</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Los registros actualizados de padres y abuelos se guardan</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Se evalúan las reglas de uso compartido basadas en criterios</td>
                  </tr>
                  <tr>
                    <td>7</td>
                    <td>Las operaciones DML se confirman en la base de datos</td>
                  </tr>
                  <tr>
                    <td>8</td>
                    <td>Se ejecuta la lógica posterior a la confirmación</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <hr>
            <p>So now with the knowledge of Order of Execution the answer to <em>How to decide a Before or After Trigger</em> is simple, always use a <code>before</code> trigger unless
              there is a need to use components like ID that require an <code>after</code> trigger and this is coming purely from my experience and other developers.</p>
            <p>Ahora que sabemos cómo escribir un disparador, necesitamos optimizar y seguir las 2 reglas clave:</p>
            <h3>1 Disparador. 1 Objeto.</h3>
            <p>Cómo 2 personas no deben beber de la misma taza de café al mismo tiempo, cada objeto no debe tener más de 1 gatillo. Tener más de un disparador eventualmente causará problemas a medida que el código se vuelve complejo, especialmente en un entorno de equipo. Esto también es para reducir el código conflictivo y mantenerse dentro de los límites del gobernador (más sobre esto mañana).</p>
            <h3>Clase de ayudante de activación</h3>
            <p>Escribir todo el código en el propio disparador resulta en archivos de aspecto más grande y complejo que más tarde pueden causar problemas. Para evitar esto, llamamos a una clase y le pasamos valores en su lugar, y la llamamos Clase Ayudante. Piénsalo de esta manera, puedes beber directamente tu café de la prensa francesa o incluso de la olla, pero una taza reduce el desorden de beber el café.</p>

            <p>Reescribamos nuestro disparador FirstNamer para usar una clase de ayuda.</p>
            <h4>Archivo de activación de FirstNamer</h4>
            <pre><code>trigger FirstName on Contact(after update){
    FirstNameHelper.replaceName(trigger.old);
}
</code></pre>
            <h4>Archivo de clase de nombre</h4>
            <pre><code>public class FirstNameHelper{

    public static void replaceName(List&lt;Contact&gt; con){
        List&lt;ID&gt; conId = new List&lt;ID&gt;();
        List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();

        for (Contact iterator: con){
            if(iterator.FirstName == 'John'){
                conId.add(iterator.Id);
            }
        }

        List&lt;Contact&gt; updateList = [SELECT ID, FirstName FROM Contact WHERE ID = :conId];

        for (Contact iterator: updateList){
            iterator.FirstName = 'Smith';
            finalList.add(iterator);
        }

        update finalList;
    }
}
</code></pre>
            <p>While most of our code remains the same, we made one big change. In our trigger class, we pass the <code>trigger.old</code> as an input parameter to our helper class, that
              has a method called <code>replaceName</code> that takes a list of contacts as an input. We know <code>trigger.old</code> will be a list of contacts because we are running it within the context of the <code>Contact</code>
              object,<code>trigger FirstName on Contact</code>. But what if we want to execute different helper classes at different times?</p>
            <p>Let’s say in our example, we have a trigger called <code>NameReplacer</code> that runs on the <code>Contact</code> Object and runs at two different times. When it’s
              <code>before insert</code>, we want to run a method <code>firstName()</code> that replaces first name, and during the <code>after update</code> we want to run a method <code>lastName()</code> that replaces last name. We use Trigger
              Context Variables to achieve this.</p>
            <h2>Variables de contexto de activación</h2>
            <p>Todos los disparadores permiten al desarrollador acceder al contexto en tiempo de ejecución, lo que significa aproximadamente que podemos definir qué procesos se ejecutan a qué hora. Esto está disponible en métodos de clase Trigger, disponible <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_context_variables.htm" target="_blank">aquí en la documentación oficial</a>:</p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Variable</th>
                    <th>Uso</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>isExecuting</td>
                    <td>Devuelve true si el contexto actual para el código Apex es un disparador, no una página de Visualforce, un servicio web o una llamada a la API executeanonymous().</td>
                  </tr>
                  <tr>
                    <td>isInsert</td>
                    <td>Devuelve true si este disparador se disparó debido a una operación de inserción, desde la interfaz de usuario de Salesforce, Apex o la API.</td>
                  </tr>
                  <tr>
                    <td>isUpdate</td>
                    <td>Devuelve true si este disparador se disparó debido a una operación de actualización, desde la interfaz de usuario de Salesforce, Apex o la API.</td>
                  </tr>
                  <tr>
                    <td>isDelete</td>
                    <td>Devuelve true si este disparador se disparó debido a una operación de eliminación, desde la interfaz de usuario de Salesforce, Apex o la API.</td>
                  </tr>
                  <tr>
                    <td>esAntes</td>
                    <td>Devuelve true si este disparador se activó antes de guardar cualquier registro.</td>
                  </tr>
                  <tr>
                    <td>isAfter</td>
                    <td>Devuelve true si este disparador se disparó después de guardar todos los registros.</td>
                  </tr>
                  <tr>
                    <td>isUndelete</td>
                    <td>Devuelve true si este disparador se disparó después de recuperar un registro de la Papelera de reciclaje. Esta recuperación puede ocurrir después de una operación de recuperación de la interfaz de usuario de Salesforce, Apex o la API.</td>
                  </tr>
                  <tr>
                    <td>nuevo</td>
                    <td>Devuelve una lista de las nuevas versiones de los registros de sObject. Esta lista de objetos solo está disponible en disparadores de inserción, actualización y recuperación, y los registros solo se pueden modificar antes de los disparadores.</td>
                  </tr>
                  <tr>
                    <td>newMap</td>
                    <td>Un mapa de IDs a las nuevas versiones de los registros de sObject. Este mapa solo está disponible antes de la actualización, después de insertar, después de actualizar y después de recuperar disparadores.</td>
                  </tr>
                  <tr>
                    <td>viejo</td>
                    <td>Devuelve una lista de las versiones antiguas de los registros de sObject. Esta lista de objetos solo está disponible en los disparadores de actualización y eliminación.</td>
                  </tr>
                  <tr>
                    <td>oldMap</td>
                    <td>Un mapa de IDs a las versiones antiguas de los registros de sObject. Este mapa solo está disponible en los disparadores de actualización y eliminación.</td>
                  </tr>
                  <tr>
                    <td>operationType</td>
                    <td>Devuelve una enumeración de tipo System.TriggerOperation correspondiente a la operación actual. Los valores posibles de la enumeración System.TriggerOperation son: BEFORE_INSERT, BEFORE_UPDATE, BEFORE_DELETE, AFTER_INSERT, AFTER_UPDATE, AFTER_DELETE y AFTER_UNDELETE. Si varía su lógica de programación en función de diferentes tipos de disparador, considere usar la instrucción switch con diferentes permutaciones de estados únicos de enumeración de ejecución de disparador.</td>
                  </tr>
                  <tr>
                    <td>tamaño</td>
                    <td>El número total de registros en una invocación de disparador, tanto antiguos como nuevos.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Escribamos nuestro disparador <code>NameReplacer</code>:</p>
            <pre><code>trigger NameReplacer on Contact(before insert, after update){
    if (Trigger.isBefore &amp;&amp; Trigger.isInsert){
        firstName();
    }
    if (Trigger.isAfter &amp;&amp; Trigger.isUpdate){
        lastName();
    }
}</code></pre>
            <p>Alternatively, this can be written in nested <code>if</code> statements:</p>
            <pre><code>trigger NameReplacer on Contact(before insert, after update){
    if (Trigger.isBefore){
        if(Trigger.isInsert){
            firstName();
        }
    }

    if (Trigger.isAfter){
        if(Trigger.isUpdate){
            lastName();
        }
    }
}</code></pre>
            <p>Either ways works and is on the developer to choose which format they prefer. Personally, I prefer nesting inside <code>if</code> statements to keep the file easily
              readable. We will look into remaining Trigger Context Variables like <code>oldMap</code> and <code>newMap</code> in the next chapter.</p>
            <p>La siguiente pregunta que viene al instante es <em>¿Por qué escribir disparadores cuando se pueden usar Flows/Process Builder/Workflow en su lugar?</em>. Una respuesta muy simple para las funcionalidades que se superponen (como actualizar un registro), es puramente <em>lo que prefieres</em>. Si estoy trabajando en una organización y necesito actualizar los contactos basados en un criterio, escribiré una clase de disparador y ayuda porque me siento cómodo con ella, pero mi colega que es un administrador podría terminar haciendo un flujo que hace el mismo trabajo. Aparte de la preferencia, los desencadenantes en realidad sobresalen cuando se trata de probar automatizaciones más complejas que se pueden hacer utilizando flujos, y requieren menos potencia informática para ejecutarse haciéndolos más rápidos. Donde los disparadores, o escribir Apex en general carece de atrás es el hecho de que <em>no puede escribir su código en producción</em>. Todo el código Apex debe estar en un entorno sandbox y necesita pasar una cobertura de código del 75% para ser trasladado a la producción.</p>
            <p>Analizamos más las clases de prueba de Apex y otros requisitos técnicos más adelante en el curso.</p>
            <h1>Resumen</h1>
            <ul>
              <li>Los disparadores se ejecutan cuando se manipula un registro.</li>
              <li>Los desencadenantes deben escribirse con una clase de ayuda.</li>
              <li>Las variables de contexto de activación le permiten acceder al contexto en tiempo de ejecución.</li>
              <li>Orden de ejecución es cómo un registro pasa del texto en pantalla a guardarse en la base de datos.</li>
              <li>Use a <code>before</code> trigger by default and <code>after</code> trigger when usage of ID is required.</li>
            </ul>


            <a href="12.html" class="global-button">Día 12: Trigger.oldMap y Trigger.newMap</a>
          </div>
        </article>

      </main>
      <footer class="footer-section global-footer">
        <div class="footer-copyright">© <a href="http://harshdeephura.com" target="_blank">Harshdeep Singh Hura</a>.<br>Todos los derechos reservados.</div>
      </footer>
    </div>
  </div>




  <script src="../assets/js/global.js"></script>




</body></html>

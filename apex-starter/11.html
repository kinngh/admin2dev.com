<html lang="de-DE"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Apex-Startkurs | Admin2Dev</title>
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@500&amp;family=Spartan:wght@500;600;700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Muli:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="../assets/css/stylesheet.css">

  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

  <meta property="og:site_name" content="Admin2Dev">

  <meta property="og:title" content="Apex Triggers and Order of Execution"> <!-- Content Title-->
  <meta property="og:description" content="Learn what are Apex Triggers and the Order of Execution in Salesforce"> <!-- Content Description -->
  <meta property="og:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:url" content="https://admin2dev.com/">


  <meta property="article:author" content="https://twitter.com/kinngh">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Apex Triggers and Order of Execution"> <!-- Twitter Title -->
  <meta name="twitter:description" content="Learn what are Apex Triggers and the Order of Execution in Salesforce"> <!-- Twitter description -->
  <meta name="twitter:url" content="https://admin2dev.com">
  <meta name="twitter:label1" content="Written by">
  <meta name="twitter:data1" content="Harshdeep Singh Hura">
  <meta name="twitter:label2" content="Filed under">
  <meta name="twitter:data2" content="Apex Tutorials">
  <meta name="twitter:site" content="@kinngh">
  <meta name="twitter:creator" content="@kinngh">
  <meta name="twitter:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-112097931-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-112097931-2');
</script><script async src="https://hm-ackee.herokuapp.com/tracker.js" data-ackee-server="https://hm-ackee.herokuapp.com" data-ackee-domain-id="f764576c-4a20-4e1e-af10-84d9528cc19f"></script>

</head>

<body id="myBody" class="global-hash-post-card-amber global-hash-post-card-apricot global-hash-post-card-aqua global-hash-post-card-coral global-hash-post-card-cream global-hash-post-card-green global-hash-post-card-purple global-hash-post-card-raspberry global-hash-post-card-sky is-loaded">
  <div class="global-wrap">
    <div class="global-content">
      <header class="header-section">
        <div class="header-wrap">
          <div class="header-logo">
            <a href="../index.html" class="is-image">
              <img src="../images/logo.png" alt="Admin2Dev">
            </a>
          </div>
          <div class="header-nav">
            <input id="toggle" class="header-checkbox" type="checkbox">
            <label class="header-toggle" for="toggle">
              <span>
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
              </span>
            </label>
            <nav>
              <ul>
                <li><a href="../index.html">Startseite</a></li>
                <li><a href="../learn/index.html">Lernen</a></li>
<li><a href="../tools/index.html">Werkzeuge</a></li>
                 <li><a href="../sponsor/index.html">Sponsor</a></li>
                <li class="header-nav-dropdown">
                  <svg role="img" viewBox="0 0 20 4" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 4A2 2 0 102.001.001 2 2 0 002 4zm8 0a2 2 0 10.001-3.999A2 2 0 0010 4zm8 0a2 2 0 10.001-3.999A2 2 0 0018 4z"></path></svg>
                  <ul>
                    <li><a href="../about/index.html">Über</a></li><li><a href="../terms.html">Nutzungsbestimmungen</a></li>
                    <li><a href="../privacy.html">Datenschutzerklärung</a></li>
                  </ul>
                </li>
              </ul>
              <ul>
                <li class="signup global-button"><a href="https://discord.gg/5ndr5F8" target="_blank">Treten Sie der Community bei</a></li>
                <li class="signin"><a onclick="darkMode()" id="darkModeText">Dunkler Modus</a></li>
              </ul>
            </nav>
          </div>
        </div>
      </header>
      <main class="global-main">
        <article class="post-section">
          <div class="post-header item is-hero is-page is-first post no-image page">
            <div class="item-container global-color">
              <div class="item-content">
                <h2 class="item-title">Apex-Trigger und Ausführungsreihenfolge</h2>
              </div>
            </div>
          </div>
          <div class="post-content">

            <p>Wenn ein Ereignis in Salesforce stattfindet, folgt es einer <em>Reihenfolge der Ausführung </em>(weiter unten in diesem Kapitel beschrieben), die Trigger an mehreren Punkten aufruft und eine der vielen Möglichkeiten ist, Apex-Code aufzurufen. Wenn wir Auslöser in einem Kaffeeherstellungsprozess sehen, führt sie eine Reihe von Aktionen durch, wenn bestimmte Ereignisse stattfinden. Wenn wir zum Beispiel Wasser in den Topf geben, um zu kochen, warten wir normalerweise, bis Dampf herauskommt, bevor wir ihn ausgießen, als ob etwas im Gehirn geht<em>, wenn Dampf herauskommt, Wasser gießen</em>.</p>
            <p>Um einen Trigger zu schreiben, wählen wir Datei &gt; Neu &gt; Apex Trigger (anstelle von Apex Class) in der Entwicklerkonsole. Die Syntax zum Schreiben eines Triggers lautet:</p>
            <pre><code>trigger TriggerName on Object(triggerEvents){
    //code
}
</code></pre>
            <ul>
              <li><code>trigger</code>Schlüsselwort für die Initialisierung eines Triggers.</li>
              <li><code>TriggerName</code>Ist der Name, der diesem Trigger zugewiesen ist.</li>
              <li><code>on</code>Schlüsselwort, das definiert, für welches Objekt wir es ausführen.</li>
              <li><code>Object</code>Ist der Name des Objekts, auf dem der Trigger ausgeführt wird.</li>
              <li><code>triggerEvents</code> defines <em>when</em> and on <em>what event</em> will the trigger run using the keywords <code>before</code> or <code>after</code> followed by
                standard DML operations like <code>insert</code>. Multiple trigger events are separated using a <code>,</code>.</li>
            </ul>
            <p>Es gibt zwei wichtige Trigger-Klassenmethoden zu kennen:</p>
            <ul>
              <li><code>Trigger.new</code>Enthält alle Werte, die neu im Objekt sind.</li>
              <li><code>Trigger.old</code>Enthält alle Werte, die sich vor der Aktualisierung im Objekt befanden.</li>
            </ul>
            <p>A real-life example is you take a cup. First you fill it with water, then you pour the water out and add milk in it. <code>Trigger.new</code> will return the value
              <code>milk</code>, and <code>Trigger.old</code> will return the value <code>water</code> when run on the cup. Let’s write a simple trigger on Contact object that checks if the First Name is empty, and fills it as ‘John’ if it is empty.
            </p>
            <pre><code>trigger FirstNamer on Contact(before insert){
    List&lt;Contact&gt; con = Trigger.new;

    for (Contact iterator: con){

        if(iterator.FirstName == null){
            iterator.FirstName = 'John';
        }
    }

}
</code></pre>
            <p>Now let’s head over to our org and make 2 new entries in the Contact object. The first entry should have First and Last Names and the second should have only a Last Name.
              You will notice the second record where no First name was specified, the value <code>John</code> has now been filled instead. Let’s write a trigger that makes use of <code>Trigger.old</code>.</p>
            <p>This new trigger runs on the Contact object and if the old First Name of a Contact was <code>John</code>, we want to replace whatever new value the user has put in with
              <code>Smith</code> instead. So if a person with the name <code>John Cool</code> existed in the database and a user tries to update the first name from <code>John</code> to anything else, the value gets saved as <code>Smith</code>
              instead.</p>
            <pre><code>trigger FirstName on Contact(after update){

    List&lt;Contact&gt; con = Trigger.old;
    List&lt;ID&gt; conId = new List&lt;ID&gt;();
    List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();

    for (Contact iterator: con){
        if(iterator.FirstName == 'John'){
            conId.add(iterator.Id);
        }
    }

    List&lt;Contact&gt; updateList = [SELECT ID, FirstName FROM Contact WHERE ID = :conId];

    for (Contact iterator: updateList){
        iterator.FirstName = 'Smith';
        finalList.add(iterator);
    }

    update finalList;

}
</code></pre>
            <p>Während dies wie eine Menge Code erscheint, ist es mit einer Aufschlüsselung leicht zu verstehen:</p>
            <ul>
              <li>First we make an <code>after update</code> trigger. The reason behind this is <code>Trigger.old</code> doesn’t exist until a change has occurred in the values.</li>
              <li>Wir erstellen 3 Listen. <code>con</code>, um alte Werte zu speichern. <code>conId</code>, um die IDs der Werte zu speichern, die wir aktualisieren müssen. <code>finalList</code>, um die Werte zu aktualisieren.</li>
              <li>The for loop that runs on <code>con</code> goes over the old values and searches for contacts where the First Name was <code>John</code> and stores just he ID in
                <code>conId</code> list.</li>
              <li>Jetzt führen wir eine SOQL-Abfrage aus, um alle Datensätze mit übereinstimmenden IDs zu erhalten, die derzeit in unserer Datenbank vorhanden sind.</li>
              <li>Die for-Schleife läuft über die Spiele und ändert ihren Vornamen in <code>Smith Cool</code>.</li>
            </ul>
            <p>Die erste Frage, die sich stellt, ist <em>Wann Vorher-Nachher-Trigger zu verwenden sind</em>. Dafür müssen wir zuerst die <em>Reihenfolge der Ausführung </em>verstehen.</p>
            <hr>
            <h2>Reihenfolge der Vollstreckung</h2>
            <p>Genau wie der Kaffeeherstellungsprozess, der einer bestimmten Reihenfolge folgt, ist die Reihenfolge der Ausführung eine Folge von Ereignissen, die auftreten, wenn ein Einfüge-, Aktualisierungs- oder Upsert-Vorgang in Salesforce stattfindet. Alle Ereignisse in der Reihenfolge der Ausführung müssen erfolgreich ausgeführt werden, bevor Daten in die Datenbank festgeschrieben werden, und wenn ein Fehler auftritt, werden alle Änderungen zurückgesetzt und keine weiteren Ereignisse ausgeführt. Unten finden Sie die Reihenfolge der Ausführung in der Reihenfolge des Auftretens direkt aus der Salesforce-Dokumentation, die <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_order_of_execution.htm" target="_blank">hier </a>verfügbar ist<a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_order_of_execution.htm" target="_blank">.</a></p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Sequenz</th>
                    <th>Veranstaltung</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>Lädt den ursprünglichen Datensatz aus der Datenbank oder initialisiert den Datensatz für eine upsert-Anweisung.</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Lädt die neuen Datensatzfeldwerte aus der Anforderung und überschreibt die alten Werte. *</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Führt Flows aus, die vor dem Speichern Aktualisierungen vornehmen.</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Führt alle vor Triggern aus.</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Führt die meisten Systemvalidierungsschritte erneut aus, z.B. um zu überprüfen, ob alle erforderlichen Felder einen Wert ungleich Null haben, und führt alle benutzerdefinierten Validierungsregeln aus. Die einzige Systemvalidierung, die Salesforce nicht ein zweites Mal ausführt (wenn die Anforderung von einer Standard-Benutzeroberflächenbearbeitungsseite stammt), ist die Durchsetzung layoutspezifischer Regeln.</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Führt doppelte Regeln aus. Wenn die duplizierte Regel den Datensatz als Duplikat identifiziert und die Blockaktion verwendet, wird der Datensatz nicht gespeichert und es werden keine weiteren Schritte unternommen, wie z.B. nach Triggern und Workflowregeln.</td>
                  </tr>
                  <tr>
                    <td>7</td>
                    <td>Speichert den Datensatz in der Datenbank, schreibt aber noch nicht fest.</td>
                  </tr>
                  <tr>
                    <td>8</td>
                    <td>Führt alle nach Triggern aus.</td>
                  </tr>
                  <tr>
                    <td>9</td>
                    <td>Führt Zuweisungsregeln aus.</td>
                  </tr>
                  <tr>
                    <td>10</td>
                    <td>Führt Regeln für die automatische Reaktion aus.</td>
                  </tr>
                  <tr>
                    <td>11</td>
                    <td>Führt Workflow-Regeln aus.</td>
                  </tr>
                  <tr>
                    <td>12</td>
                    <td>Wenn Workflow-Feldaktualisierungen vorliegen, aktualisiert den Datensatz erneut.</td>
                  </tr>
                  <tr>
                    <td>13</td>
                    <td>Wenn der Datensatz mit Workflow-Feldaktualisierungen aktualisiert wurde, wird ausgelöst, bevor die Aktualisierung ausgelöst wird und nachdem die Aktualisierung zusätzlich zu den Standardüberprüfungen noch einmal (und nur noch einmal) ausgelöst wird. Benutzerdefinierte Validierungsregeln, Flows, doppelte Regeln, Prozesse und Eskalationsregeln werden nicht erneut ausgeführt.</td>
                  </tr>
                  <tr>
                    <td>14</td>
                    <td>Führt Prozesse und Flows aus, die über Prozesse gestartet werden, und Flow-Trigger-Workflow-Aktionen. Wenn ein Prozess oder Flow einen DML-Vorgang ausführt, durchläuft der betroffene Datensatz die Speicherprozedur.</td>
                  </tr>
                  <tr>
                    <td>15</td>
                    <td>Führt Eskalationsregeln aus.</td>
                  </tr>
                  <tr>
                    <td>16</td>
                    <td>Führt Anspruchsregeln aus.</td>
                  </tr>
                  <tr>
                    <td>17</td>
                    <td>Wenn der Datensatz ein Rollup-Zusammenfassungsfeld enthält oder Teil eines objektübergreifenden Workflows ist, führt Berechnungen durch und aktualisiert das Rollup-Zusammenfassungsfeld im übergeordneten Datensatz. Der übergeordnete Datensatz durchläuft die Speicherprozedur.</td>
                  </tr>
                  <tr>
                    <td>18</td>
                    <td>Wenn der übergeordnete Datensatz aktualisiert wird und ein übergeordneter Datensatz ein Zusammenfassungsfeld für die Zusammenfassung enthält oder Teil eines objektübergreifenden Workflows ist, führt Berechnungen durch und aktualisiert das Zusammenfassungsfeld für die Zusammenfassung der Gruppe im übergeordneten Datensatz. Der Großelterndatensatz durchläuft die Speicherprozedur.</td>
                  </tr>
                  <tr>
                    <td>19</td>
                    <td>Führt eine kriterienbasierte Freigabebewertung durch.</td>
                  </tr>
                  <tr>
                    <td>20</td>
                    <td>Schreibt alle DML-Vorgänge in die Datenbank fest.</td>
                  </tr>
                  <tr>
                    <td>21</td>
                    <td>Führt die Logik nach der Verpflichtung aus, wie z.B. das Senden von E-Mails.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Fortsetzung auf Sequenz 2:</p>
            <ul>
              <li>Wenn die Anforderung von einer Standard-UI-Bearbeitungsseite stammt, führt Salesforce eine Systemvalidierung durch, um den Datensatz zu überprüfen auf:<ul>
                  <li>Einhaltung von layoutspezifischen Regeln</li>
                  <li>Erforderliche Werte auf Layout- und Felddefinitionsebene</li>
                  <li>Gültige Feldformate</li>
                  <li>Maximale Feldlänge</li>
                </ul>
              </li>
              <li>Wenn die Anforderung aus anderen Quellen kommt, wie z.B. einer Apex-Anwendung oder einem SOAP-API-Aufruf, validiert Salesforce nur die Fremdschlüssel. Vor der Ausführung eines Triggers überprüft Salesforce, ob sich benutzerdefinierte Fremdschlüssel nicht auf das Objekt selbst beziehen.</li>
              <li>Salesforce führt benutzerdefinierte Validierungsregeln aus, wenn mehrzeilige Elemente erstellt wurden, wie z.B. Angebotspositionen und Absatzchancenpositionen.</li>
            </ul>
            <p>Die gesamte Reihenfolge der Ausführung kann in 3 kleinere Tabellen unterteilt werden, die leichter zu verstehen sind:</p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Sequenz</th>
                    <th>Veranstaltung</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>Ursprünglicher Datensatz wird geladen ODER neue Datensätze werden initialisiert</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Feldwerte werden in sObjects geladen</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Bevor Trigger ausgeführt werden</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Systemvalidierungsregeln werden erneut ausgeführt und benutzerdefinierte Validierungsregeln werden überprüft.</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>1</td>
                    <td>Doppelte Regeln werden ausgeführt</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Datensatz wird gespeichert, aber nicht festgeschrieben</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Nachdem Trigger ausgeführt wurden</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Zuweisungsregeln werden ausgeführt</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Regeln für die automatische Antwort werden ausgeführt</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Vor Triggern werden Systemvalidierungsregeln und nach Triggern aufgrund von Workflow-Feldaktualisierungen ausgeführt</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>1</td>
                    <td>Prozesse werden ausgeführt</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Eskalationsregeln werden ausgeführt</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Berechtigungsregeln werden ausgeführt</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Zusammenfassungsfelder und objektübergreifende Formelfelder werden aktualisiert</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Aktualisierte übergeordnete und übergeordnete Datensätze werden gespeichert</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Kriterienbasierte Freigaberegeln werden ausgewertet</td>
                  </tr>
                  <tr>
                    <td>7</td>
                    <td>DML-Vorgänge werden in der Datenbank festgeschrieben</td>
                  </tr>
                  <tr>
                    <td>8</td>
                    <td>Post-Commit-Logik wird ausgeführt</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <hr>
            <p>So now with the knowledge of Order of Execution the answer to <em>How to decide a Before or After Trigger</em> is simple, always use a <code>before</code> trigger unless
              there is a need to use components like ID that require an <code>after</code> trigger and this is coming purely from my experience and other developers.</p>
            <p>Jetzt, da wir wissen, wie man einen Trigger schreibt, müssen wir die 2 Schlüsselregeln optimieren und befolgen:</p>
            <h3>1 Auslöser. 1 Objekt.</h3>
            <p>Wie 2 Personen nicht gleichzeitig aus derselben Tasse Kaffee trinken sollten, sollte jedes Objekt nicht mehr als 1 Auslöser haben. Wenn Sie mehr als einen Trigger haben, wird der Code schließlich Probleme verursachen, da der Code komplex wird, insbesondere in einer Teamumgebung. Dies soll auch widersprüchlichen Code reduzieren und innerhalb der Governor Limits bleiben (mehr dazu morgen).</p>
            <h3>Trigger-Helferklasse</h3>
            <p>Das Schreiben des gesamten Codes in den Trigger selbst führt zu größeren, komplex aussehenden Dateien, die später Probleme verursachen können. Um dies zu vermeiden, rufen wir eine Klasse auf und übergeben stattdessen Werte an sie und nennen sie eine Helferklasse. Stellen Sie es sich so vor, Sie können Ihren Kaffee direkt von der französischen Presse oder sogar von der Kanne trinken, aber eine Tasse reduziert das Durcheinander beim Trinken des Kaffees.</p>

            <p>Schreiben wir unseren FirstNamer-Trigger neu, um eine Hilfsklasse zu verwenden.</p>
            <h4>FirstNamer Trigger-Datei</h4>
            <pre><code>trigger FirstName on Contact(after update){
    FirstNameHelper.replaceName(trigger.old);
}
</code></pre>
            <h4>FirstNamer-Klassendatei</h4>
            <pre><code>public class FirstNameHelper{

    public static void replaceName(List&lt;Contact&gt; con){
        List&lt;ID&gt; conId = new List&lt;ID&gt;();
        List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();

        for (Contact iterator: con){
            if(iterator.FirstName == 'John'){
                conId.add(iterator.Id);
            }
        }

        List&lt;Contact&gt; updateList = [SELECT ID, FirstName FROM Contact WHERE ID = :conId];

        for (Contact iterator: updateList){
            iterator.FirstName = 'Smith';
            finalList.add(iterator);
        }

        update finalList;
    }
}
</code></pre>
            <p>While most of our code remains the same, we made one big change. In our trigger class, we pass the <code>trigger.old</code> as an input parameter to our helper class, that
              has a method called <code>replaceName</code> that takes a list of contacts as an input. We know <code>trigger.old</code> will be a list of contacts because we are running it within the context of the <code>Contact</code>
              object,<code>trigger FirstName on Contact</code>. But what if we want to execute different helper classes at different times?</p>
            <p>Let’s say in our example, we have a trigger called <code>NameReplacer</code> that runs on the <code>Contact</code> Object and runs at two different times. When it’s
              <code>before insert</code>, we want to run a method <code>firstName()</code> that replaces first name, and during the <code>after update</code> we want to run a method <code>lastName()</code> that replaces last name. We use Trigger
              Context Variables to achieve this.</p>
            <h2>Trigger-Kontextvariablen</h2>
            <p>Alle Trigger ermöglichen es dem Entwickler, auf den Laufzeitkontext zuzugreifen, was ungefähr bedeutet, dass wir definieren können, welche Prozesse zu welcher Zeit ausgeführt werden. Dies ist in Methoden der Trigger-Klasse verfügbar, die <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_context_variables.htm" target="_blank">hier in der offiziellen Dokumentation </a>verfügbar <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_context_variables.htm" target="_blank">sind</a>:</p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Variabel</th>
                    <th>Verwendungszweck</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>isExecuting</td>
                    <td>Gibt TRUE zurück, wenn der aktuelle Kontext für den Apex-Code ein Trigger ist, keine Visualforce-Seite, ein Webdienst oder ein executeanonymous()-API-Aufruf.</td>
                  </tr>
                  <tr>
                    <td>isInsert</td>
                    <td>Gibt TRUE zurück, wenn dieser Trigger aufgrund eines Einfügevorgangs von der Salesforce-Benutzeroberfläche, Apex oder der API ausgelöst wurde.</td>
                  </tr>
                  <tr>
                    <td>isUpdate</td>
                    <td>Gibt TRUE zurück, wenn dieser Trigger aufgrund eines Aktualisierungsvorgangs über die Salesforce-Benutzeroberfläche, Apex oder die API ausgelöst wurde.</td>
                  </tr>
                  <tr>
                    <td>isDelete</td>
                    <td>Gibt TRUE zurück, wenn dieser Trigger aufgrund eines Löschvorgangs über die Salesforce-Benutzeroberfläche, Apex oder die API ausgelöst wurde.</td>
                  </tr>
                  <tr>
                    <td>IstVor</td>
                    <td>Gibt TRUE zurück, wenn dieser Trigger ausgelöst wurde, bevor ein Datensatz gespeichert wurde.</td>
                  </tr>
                  <tr>
                    <td>isAfter</td>
                    <td>Gibt TRUE zurück, wenn dieser Trigger ausgelöst wurde, nachdem alle Datensätze gespeichert wurden.</td>
                  </tr>
                  <tr>
                    <td>isUndelete</td>
                    <td>Gibt TRUE zurück, wenn dieser Trigger ausgelöst wurde, nachdem ein Datensatz aus dem Papierkorb wiederhergestellt wurde. Diese Wiederherstellung kann nach einem Wiederherstellungsvorgang über die Salesforce-Benutzeroberfläche, Apex oder die API erfolgen.</td>
                  </tr>
                  <tr>
                    <td>neu</td>
                    <td>Gibt eine Liste der neuen Versionen der sObject-Datensätze zurück. Diese sObject-Liste ist nur in Einfüge-, Aktualisierungs- und Wiederherstellung-Triggern verfügbar, und die Datensätze können nur in vor Triggern geändert werden.</td>
                  </tr>
                  <tr>
                    <td>NewMap</td>
                    <td>Eine Zuordnung von IDs zu den neuen Versionen der sObject-Datensätze. Diese Karte ist nur vor dem Update, nach dem Einfügen, nach dem Update und nach dem Rückgängigmachen von Triggern verfügbar.</td>
                  </tr>
                  <tr>
                    <td>Alt</td>
                    <td>Gibt eine Liste der alten Versionen der sObject-Datensätze zurück. Diese sObject-Liste ist nur in Update- und Lösch-Triggern verfügbar.</td>
                  </tr>
                  <tr>
                    <td>oldMap</td>
                    <td>Eine Zuordnung von IDs zu den alten Versionen der sObject-Datensätze. Diese Karte ist nur in Update- und Löschauslösern verfügbar.</td>
                  </tr>
                  <tr>
                    <td>OperationTyp</td>
                    <td>Gibt eine Enumeration vom Typ System.TriggerOperation zurück, die der aktuellen Operation entspricht. Mögliche Werte der System.TriggerOperation-Enumeration sind: BEFORE_INSERT, BEFORE_UPDATE, BEFORE_DELETE, AFTER_INSERT, AFTER_UPDATE, AFTER_DELETE und AFTER_UNDELETE. Wenn Sie Ihre Programmierlogik basierend auf verschiedenen Triggertypen variieren, sollten Sie die switch-Anweisung mit unterschiedlichen Permutationen eindeutiger Triggerausführungs-Enumerationszustände verwenden.</td>
                  </tr>
                  <tr>
                    <td>Größe</td>
                    <td>Die Gesamtzahl der Datensätze in einem Triggeraufruf, sowohl alt als auch neu.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Let’s write our <code>NameReplacer</code> trigger:</p>
            <pre><code>trigger NameReplacer on Contact(before insert, after update){
    if (Trigger.isBefore &amp;&amp; Trigger.isInsert){
        firstName();
    }
    if (Trigger.isAfter &amp;&amp; Trigger.isUpdate){
        lastName();
    }
}</code></pre>
            <p>Alternatively, this can be written in nested <code>if</code> statements:</p>
            <pre><code>trigger NameReplacer on Contact(before insert, after update){
    if (Trigger.isBefore){
        if(Trigger.isInsert){
            firstName();
        }
    }

    if (Trigger.isAfter){
        if(Trigger.isUpdate){
            lastName();
        }
    }
}</code></pre>
            <p>Either ways works and is on the developer to choose which format they prefer. Personally, I prefer nesting inside <code>if</code> statements to keep the file easily
              readable. We will look into remaining Trigger Context Variables like <code>oldMap</code> and <code>newMap</code> in the next chapter.</p>
            <p>Die nächste Frage, die sofort gestellt wird<em>, </em>ist <em>Warum Trigger schreiben, wenn stattdessen Flows/Process Builder/Workflow verwendet werden können?</em> Eine sehr einfache Antwort auf Funktionen, die sich überschneiden (wie das Aktualisieren eines Datensatzes), ist nur das<em>, was Sie bevorzugen</em>. Wenn ich an einer Organisation arbeite und Kontakte basierend auf einem Kriterium aktualisieren muss, werde ich eine Trigger- und Hilfsklasse schreiben, weil ich damit vertraut bin, aber mein Kollege, der Administrator ist, könnte am Ende einen Flow machen, der die gleiche Arbeit erfüllt. Abgesehen von der Präferenz zeichnen sich Trigger tatsächlich aus, wenn es darum geht, komplexere Automatisierungen zu testen, die mit Flows durchgeführt werden können, und benötigen weniger Rechenleistung, um sie schneller auszuführen. Wo Trigger oder das Schreiben von Apex im Allgemeinen nicht dahinter fehlen, ist die Tatsache, dass <em>Sie Ihren Code nicht in der Produktion schreiben können</em>. Der gesamte Apex-Code muss sich in einer Sandbox-Umgebung befinden und eine 75 % Codeabdeckung bestehen, um in die Produktion übertragen zu werden.</p>
            <p>Wir befassen uns später im Kurs mit Apex-Testkursen und anderen technischen Anforderungen.</p>
            <h1>Zusammenfassung</h1>
            <ul>
              <li>Trigger werden ausgeführt, wenn ein Datensatz bearbeitet wird.</li>
              <li>Trigger sollten mit einer Hilfsklasse geschrieben werden.</li>
              <li>Trigger-Kontextvariablen ermöglichen es Ihnen, auf den Laufzeitkontext zuzugreifen.</li>
              <li>Reihenfolge der Ausführung ist, wie ein Datensatz von Text auf dem Bildschirm in der Datenbank gespeichert wird.</li>
              <li>Use a <code>before</code> trigger by default and <code>after</code> trigger when usage of ID is required.</li>
            </ul>


            <a href="12.html" class="global-button">Tag 12: Trigger.oldMap und Trigger.newMap</a>
          </div>
        </article>

      </main>
      <footer class="footer-section global-footer">
        <div class="footer-copyright">© <a href="http://harshdeephura.com" target="_blank">Harshdeep Singh Hura</a>.<br>Alle Rechte vorbehalten.</div>
      </footer>
    </div>
  </div>




  <script src="../assets/js/global.js"></script>




</body></html>

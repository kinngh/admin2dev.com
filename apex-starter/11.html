<html lang="fr-FR"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Cours de démarrage Apex | Admin2Dev</title>
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@500&amp;family=Spartan:wght@500;600;700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Muli:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="../assets/css/stylesheet.css">

  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

  <meta property="og:site_name" content="Admin2Dev">

  <meta property="og:title" content="Apex Triggers and Order of Execution"> <!-- Content Title-->
  <meta property="og:description" content="Learn what are Apex Triggers and the Order of Execution in Salesforce"> <!-- Content Description -->
  <meta property="og:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:url" content="https://admin2dev.com/">


  <meta property="article:author" content="https://twitter.com/kinngh">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Apex Triggers and Order of Execution"> <!-- Twitter Title -->
  <meta name="twitter:description" content="Learn what are Apex Triggers and the Order of Execution in Salesforce"> <!-- Twitter description -->
  <meta name="twitter:url" content="https://admin2dev.com">
  <meta name="twitter:label1" content="Written by">
  <meta name="twitter:data1" content="Harshdeep Singh Hura">
  <meta name="twitter:label2" content="Filed under">
  <meta name="twitter:data2" content="Apex Tutorials">
  <meta name="twitter:site" content="@kinngh">
  <meta name="twitter:creator" content="@kinngh">
  <meta name="twitter:image" content="https://a2d-cdn.now.sh/web-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-112097931-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-112097931-2');
</script><script async src="https://hm-ackee.herokuapp.com/tracker.js" data-ackee-server="https://hm-ackee.herokuapp.com" data-ackee-domain-id="e6e2d901-0aed-483b-bbdf-074952248f20"></script>

</head>

<body id="myBody" class="global-hash-post-card-amber global-hash-post-card-apricot global-hash-post-card-aqua global-hash-post-card-coral global-hash-post-card-cream global-hash-post-card-green global-hash-post-card-purple global-hash-post-card-raspberry global-hash-post-card-sky is-loaded">
  <div class="global-wrap">
    <div class="global-content">
      <header class="header-section">
        <div class="header-wrap">
          <div class="header-logo">
            <a href="../index.html" class="is-image">
              <img src="../images/logo.png" alt="Admin2Dev">
            </a>
          </div>
          <div class="header-nav">
            <input id="toggle" class="header-checkbox" type="checkbox">
            <label class="header-toggle" for="toggle">
              <span>
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
              </span>
            </label>
            <nav>
              <ul>
                <li><a href="../index.html">Accueil</a></li>
                <li><a href="../learn/index.html">Apprendre</a></li>
<li><a href="../tools/index.html">Outils</a></li>
                 <li><a href="../sponsor/index.html">Commanditaire</a></li>
                <li class="header-nav-dropdown">
                  <svg role="img" viewBox="0 0 20 4" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 4A2 2 0 102.001.001 2 2 0 002 4zm8 0a2 2 0 10.001-3.999A2 2 0 0010 4zm8 0a2 2 0 10.001-3.999A2 2 0 0018 4z"></path></svg>
                  <ul>
                    <li><a href="../about/index.html">À propos</a></li><li><a href="../terms.html">Conditions d'utilisation</a></li>
                    <li><a href="../privacy.html">Politique de confidentialité</a></li>
                  </ul>
                </li>
              </ul>
              <ul>
                <li class="signup global-button"><a href="https://discord.gg/5ndr5F8" target="_blank">Rejoignez la communauté</a></li>
                <li class="signin"><a onclick="darkMode()" id="darkModeText">Mode sombre</a></li>
              </ul>
            </nav>
          </div>
        </div>
      </header>
      <main class="global-main">
        <article class="post-section">
          <div class="post-header item is-hero is-page is-first post no-image page">
            <div class="item-container global-color">
              <div class="item-content">
                <h2 class="item-title">Déclencheurs d'apex et ordre d'exécution</h2>
              </div>
            </div>
          </div>
          <div class="post-content">

            <p>Lorsqu'un événement a lieu dans Salesforce, il suit un <em>ordre d'exécution </em>(Décrit plus loin dans ce chapitre) qui appelle les déclencheurs à plusieurs points et est l'une des nombreuses façons d'invoquer le code Apex. Si nous voyons des déclencheurs dans un processus de fabrication du café, il fait un ensemble d'actions lorsque des événements spécifiques ont lieu. Par exemple, lorsque nous mettons de l'eau dans la casserole à ébullition, nous attendons généralement que la vapeur sorte avant de la verser, comme si quelque chose dans le cerveau sortait <em>si de la vapeur sort, versez de l'eau</em>.</p>
            <p>Pour écrire un déclencheur, nous sélectionnons Fichier &gt; Nouveau &gt; Déclencheur Apex (au lieu de la classe Apex) dans la console de développement. La syntaxe pour écrire un déclencheur est la suivante :</p>
            <pre><code>trigger TriggerName on Object(triggerEvents){
    //code
}
</code></pre>
            <ul>
              <li><code>trigger</code>pour initialiser un déclencheur.</li>
              <li><code>TriggerName</code>est le nom attribué à ce déclencheur.</li>
              <li><code>on</code>qui définit l'objet sur lequel nous l'exécutons.</li>
              <li><code>Object</code>est le nom de l'objet sur lequel le déclencheur s'exécutera.</li>
              <li><code>triggerEvents</code> defines <em>when</em> and on <em>what event</em> will the trigger run using the keywords <code>before</code> or <code>after</code> followed by
                standard DML operations like <code>insert</code>. Multiple trigger events are separated using a <code>,</code>.</li>
            </ul>
            <p>Il existe deux méthodes clés de classe de déclenchement à connaître :</p>
            <ul>
              <li><code>Trigger.new</code>contient toutes les valeurs qui sont nouvelles dans l'objet.</li>
              <li><code>Trigger.old</code>contient toutes les valeurs qui étaient dans l'objet avant d'être mises à jour.</li>
            </ul>
            <p>A real-life example is you take a cup. First you fill it with water, then you pour the water out and add milk in it. <code>Trigger.new</code> will return the value
              <code>milk</code>, and <code>Trigger.old</code> will return the value <code>water</code> when run on the cup. Let’s write a simple trigger on Contact object that checks if the First Name is empty, and fills it as ‘John’ if it is empty.
            </p>
            <pre><code>trigger FirstNamer on Contact(before insert){
    List&lt;Contact&gt; con = Trigger.new;

    for (Contact iterator: con){

        if(iterator.FirstName == null){
            iterator.FirstName = 'John';
        }
    }

}
</code></pre>
            <p>Now let’s head over to our org and make 2 new entries in the Contact object. The first entry should have First and Last Names and the second should have only a Last Name.
              You will notice the second record where no First name was specified, the value <code>John</code> has now been filled instead. Let’s write a trigger that makes use of <code>Trigger.old</code>.</p>
            <p>This new trigger runs on the Contact object and if the old First Name of a Contact was <code>John</code>, we want to replace whatever new value the user has put in with
              <code>Smith</code> instead. So if a person with the name <code>John Cool</code> existed in the database and a user tries to update the first name from <code>John</code> to anything else, the value gets saved as <code>Smith</code>
              instead.</p>
            <pre><code>trigger FirstName on Contact(after update){

    List&lt;Contact&gt; con = Trigger.old;
    List&lt;ID&gt; conId = new List&lt;ID&gt;();
    List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();

    for (Contact iterator: con){
        if(iterator.FirstName == 'John'){
            conId.add(iterator.Id);
        }
    }

    List&lt;Contact&gt; updateList = [SELECT ID, FirstName FROM Contact WHERE ID = :conId];

    for (Contact iterator: updateList){
        iterator.FirstName = 'Smith';
        finalList.add(iterator);
    }

    update finalList;

}
</code></pre>
            <p>Bien que cela semble être beaucoup de code, il est facile à comprendre avec une panne :</p>
            <ul>
              <li>First we make an <code>after update</code> trigger. The reason behind this is <code>Trigger.old</code> doesn’t exist until a change has occurred in the values.</li>
              <li>We make 3 lists. <code>con</code> to hold old values. <code>conId</code> to hold the IDs of values we need to update. <code>finalList</code> to update the values.</li>
              <li>The for loop that runs on <code>con</code> goes over the old values and searches for contacts where the First Name was <code>John</code> and stores just he ID in
                <code>conId</code> list.</li>
              <li>Maintenant, nous exécutons une requête SOQL pour obtenir tous les enregistrements avec des ID correspondants qui existent actuellement dans notre base de données.</li>
              <li>La boucle for passe sur les matchs et change leur prénom en <code>Smith Cool</code>.</li>
            </ul>
            <p>La première question qui se pose est <em>de savoir quand utiliser les déclencheurs avant et après</em>. Pour cela, nous devons d'abord comprendre l'ordre<em> d'exécution</em>.</p>
            <hr>
            <h2>Ordre d'exécution</h2>
            <p>Tout comme le processus de fabrication du café qui suit une séquence spécifique, l'ordre d'exécution est une séquence d'événements qui se produisent lorsqu'une opération d'insertion, de mise à jour ou d'insertion se produit dans Salesforce. Tous les événements de l'ordre d'exécution doivent s'exécuter avec succès avant que les données ne soient validées dans la base de données et en cas d'échec, toutes les modifications sont annulées et aucun autre événement n'est exécuté. Vous trouverez ci-dessous l'ordre d'exécution par ordre d'occurrence tiré directement de la documentation Salesforce disponible <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_order_of_execution.htm" target="_blank">ici</a></p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Séquence</th>
                    <th>Événement</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>Charge l'enregistrement d'origine à partir de la base de données ou initialise l'enregistrement d'une instruction upsert.</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Charge les nouvelles valeurs de champ d'enregistrement à partir de la demande et écrase les anciennes valeurs. *</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Exécute les flux qui effectuent des mises à jour avant l'enregistrement.</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Exécute tout avant les déclencheurs.</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Exécute à nouveau la plupart des étapes de validation du système, telles que la vérification que tous les champs requis ont une valeur non nulle, et exécute toutes les règles de validation définies par l'utilisateur. La seule validation système que Salesforce n'exécute pas une deuxième fois (lorsque la demande provient d'une page d'édition standard de l'interface utilisateur) est l'application de règles spécifiques à la mise en page.</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Exécute des règles en double. Si la règle de duplication identifie l'enregistrement comme un doublon et utilise l'action de bloc, l'enregistrement n'est pas enregistré et aucune autre étape, telle que les déclencheurs après et les règles de flux de travail, n'est effectuée.</td>
                  </tr>
                  <tr>
                    <td>7</td>
                    <td>Enregistre l'enregistrement dans la base de données, mais ne valide pas encore.</td>
                  </tr>
                  <tr>
                    <td>8</td>
                    <td>Exécute tout ce qui suit les déclencheurs.</td>
                  </tr>
                  <tr>
                    <td>9</td>
                    <td>Exécute les règles d'affectation.</td>
                  </tr>
                  <tr>
                    <td>10</td>
                    <td>Exécute des règles d'auto-réponse.</td>
                  </tr>
                  <tr>
                    <td>11</td>
                    <td>Exécute les règles de flux de travail.</td>
                  </tr>
                  <tr>
                    <td>12</td>
                    <td>S'il y a des mises à jour de champ de flux de travail, met à jour à nouveau l'enregistrement.</td>
                  </tr>
                  <tr>
                    <td>13</td>
                    <td>Si l'enregistrement a été mis à jour avec des mises à jour de champ de flux de travail, se déclenche avant les déclencheurs de mise à jour et après les déclencheurs de mise à jour une fois de plus (et une seule fois de plus), en plus des validations standard. Les règles de validation personnalisées, les flux, les règles en double, les processus et les règles d'escalade ne sont pas exécutés à nouveau.</td>
                  </tr>
                  <tr>
                    <td>14</td>
                    <td>Exécute les processus et les flux lancés via les processus et les actions de flux de travail du déclencheur de flux. Lorsqu'un processus ou un flux exécute une opération DML, l'enregistrement affecté passe par la procédure d'enregistrement.</td>
                  </tr>
                  <tr>
                    <td>15</td>
                    <td>Exécute des règles d'escalade.</td>
                  </tr>
                  <tr>
                    <td>16</td>
                    <td>Exécute les règles d'admissibilité.</td>
                  </tr>
                  <tr>
                    <td>17</td>
                    <td>Si l'enregistrement contient un champ de résumé cumulatif ou fait partie d'un flux de travail inter-objets, effectue des calculs et met à jour le champ de résumé cumulatif de l'enregistrement parent. L'enregistrement parent passe par la procédure d'enregistrement.</td>
                  </tr>
                  <tr>
                    <td>18</td>
                    <td>Si l'enregistrement parent est mis à jour et qu'un enregistrement grand-parent contient un champ de résumé cumulatif ou fait partie d'un flux de travail inter-objets, effectue des calculs et met à jour le champ de résumé cumulatif dans l'enregistrement grand-parent. L'enregistrement des grands-parents passe par la procédure d'enregistrement.</td>
                  </tr>
                  <tr>
                    <td>19</td>
                    <td>Exécute l'évaluation du partage basée sur des critères.</td>
                  </tr>
                  <tr>
                    <td>20</td>
                    <td>Valide toutes les opérations DML dans la base de données.</td>
                  </tr>
                  <tr>
                    <td>21</td>
                    <td>Exécute une logique post-engagement, telle que l'envoi de courriels.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Suite de la séquence 2 :</p>
            <ul>
              <li>Si la demande provient d'une page d'édition de l'interface utilisateur standard, Salesforce exécute la validation du système pour vérifier l'enregistrement :<ul>
                  <li>Conformité aux règles spécifiques à la mise en page</li>
                  <li>Valeurs requises au niveau de la mise en page et au niveau de la définition de la rubrique</li>
                  <li>Formats de champs valides</li>
                  <li>Longueur maximale du champ</li>
                </ul>
              </li>
              <li>Lorsque la demande provient d'autres sources, telles qu'une application Apex ou un appel d'API SOAP, Salesforce ne valide que les clés étrangères. Avant d'exécuter un déclencheur, Salesforce vérifie que toutes les clés étrangères personnalisées ne font pas référence à l'objet lui-même.</li>
              <li>Salesforce exécute des règles de validation définies par l'utilisateur si des éléments multilignes ont été créés, tels que des éléments de ligne de guillemet et des éléments de ligne d'opportunité.</li>
            </ul>
            <p>L'ordre d'exécution entier peut être divisé en 3 tables plus petites et plus faciles à comprendre :</p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Séquence</th>
                    <th>Événement</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>L'enregistrement original est chargé OU de nouveaux enregistrements sont initialisés</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Les valeurs de champ sont chargées dans sObjects</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Avant l'exécution des déclencheurs</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Les règles de validation du système sont à nouveau exécutées et les règles de validation personnalisées sont vérifiées</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>1</td>
                    <td>Les règles en double sont exécutées</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>L'enregistrement est enregistré mais n'est pas validé</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Après l'exécution des déclencheurs</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Les règles d'affectation sont exécutées</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Les règles de réponse automatique sont exécutées</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Avant les déclencheurs, les règles de validation du système et après l'exécution des déclencheurs en raison des mises à jour des champs de flux de travail</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>1</td>
                    <td>Les processus sont exécutés</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Les règles d'escalade sont exécutées</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Les règles d'admissibilité sont exécutées</td>
                  </tr>
                  <tr>
                    <td>4</td>
                    <td>Les champs de résumé cumulatif et les champs de formule d'objets croisés sont mis à jour</td>
                  </tr>
                  <tr>
                    <td>5</td>
                    <td>Les dossiers des parents et des grands-parents mis à jour sont enregistrés</td>
                  </tr>
                  <tr>
                    <td>6</td>
                    <td>Les règles de partage basées sur des critères sont évaluées</td>
                  </tr>
                  <tr>
                    <td>7</td>
                    <td>Les opérations DML sont validées dans la base de données</td>
                  </tr>
                  <tr>
                    <td>8</td>
                    <td>La logique de post-engagement est exécutée</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <hr>
            <p>So now with the knowledge of Order of Execution the answer to <em>How to decide a Before or After Trigger</em> is simple, always use a <code>before</code> trigger unless
              there is a need to use components like ID that require an <code>after</code> trigger and this is coming purely from my experience and other developers.</p>
            <p>Maintenant que nous savons écrire un déclencheur, nous devons optimiser et suivre les 2 règles clés :</p>
            <h3>1 Déclencheur. 1 Objet.</h3>
            <p>Juste comment 2 personnes ne devraient pas boire dans la même tasse de café en même temps, chaque objet ne devrait pas avoir plus d'une gâchette. Avoir plus d'un déclencheur finira par causer des problèmes à mesure que le code devient complexe, en particulier dans un environnement d'équipe. C'est aussi pour réduire les codes contradictoires et rester dans les limites des gouverneurs (Plus d'informations à ce sujet demain).</p>
            <h3>Classe d'aide au déclenchement</h3>
            <p>L'écriture de tout le code dans le déclencheur lui-même donne des fichiers plus gros et complexes qui peuvent plus tard causer des problèmes. Pour éviter cela, nous appelons une classe et lui passons des valeurs à la place, et nous l'appelons une classe Helper. Pensez-y de cette façon, vous pouvez boire directement votre café de la presse française ou même de la casserole, mais une tasse réduit le gâchis de boire le café.</p>

            <p>Réécrivons notre déclencheur FirstNamer pour utiliser une classe d'aide.</p>
            <h4>Fichier de déclenchement FirstNamer</h4>
            <pre><code>trigger FirstName on Contact(after update){
    FirstNameHelper.replaceName(trigger.old);
}
</code></pre>
            <h4>Fichier de classe FirstNamer</h4>
            <pre><code>public class FirstNameHelper{

    public static void replaceName(List&lt;Contact&gt; con){
        List&lt;ID&gt; conId = new List&lt;ID&gt;();
        List&lt;Contact&gt; finalList = new List&lt;Contact&gt;();

        for (Contact iterator: con){
            if(iterator.FirstName == 'John'){
                conId.add(iterator.Id);
            }
        }

        List&lt;Contact&gt; updateList = [SELECT ID, FirstName FROM Contact WHERE ID = :conId];

        for (Contact iterator: updateList){
            iterator.FirstName = 'Smith';
            finalList.add(iterator);
        }

        update finalList;
    }
}
</code></pre>
            <p>While most of our code remains the same, we made one big change. In our trigger class, we pass the <code>trigger.old</code> as an input parameter to our helper class, that
              has a method called <code>replaceName</code> that takes a list of contacts as an input. We know <code>trigger.old</code> will be a list of contacts because we are running it within the context of the <code>Contact</code>
              object,<code>trigger FirstName on Contact</code>. But what if we want to execute different helper classes at different times?</p>
            <p>Let’s say in our example, we have a trigger called <code>NameReplacer</code> that runs on the <code>Contact</code> Object and runs at two different times. When it’s
              <code>before insert</code>, we want to run a method <code>firstName()</code> that replaces first name, and during the <code>after update</code> we want to run a method <code>lastName()</code> that replaces last name. We use Trigger
              Context Variables to achieve this.</p>
            <h2>Déclencher des variables de contexte</h2>
            <p>Tous les déclencheurs permettent au développeur d'accéder au contexte d'exécution, ce qui signifie approximativement que nous pouvons définir quels processus s'exécutent à quelle heure. Ceci est disponible dans les méthodes de la classe Trigger, disponibles <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_context_variables.htm" target="_blank">ici dans la documentation officielle </a>:</p>
            <div class="responsive-table">
              <table>
                <thead>
                  <tr>
                    <th>Variable</th>
                    <th>Utilisation</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>est en train d'exécution</td>
                    <td>Renvoie true si le contexte actuel du code Apex est un déclencheur, pas une page Visualforce, un service Web ou un appel d'API executeanonymous().</td>
                  </tr>
                  <tr>
                    <td>isInsert</td>
                    <td>Renvoie true si ce déclencheur a été déclenché en raison d'une opération d'insertion, à partir de l'interface utilisateur Salesforce, d'Apex ou de l'API.</td>
                  </tr>
                  <tr>
                    <td>isUpdate</td>
                    <td>Renvoie true si ce déclencheur a été déclenché en raison d'une opération de mise à jour, à partir de l'interface utilisateur Salesforce, d'Apex ou de l'API.</td>
                  </tr>
                  <tr>
                    <td>isDelete</td>
                    <td>Renvoie true si ce déclencheur a été déclenché en raison d'une opération de suppression, à partir de l'interface utilisateur Salesforce, d'Apex ou de l'API.</td>
                  </tr>
                  <tr>
                    <td>isBefore</td>
                    <td>Renvoie true si ce déclencheur a été déclenché avant qu'un enregistrement ne soit enregistré.</td>
                  </tr>
                  <tr>
                    <td>isAfter</td>
                    <td>Renvoie true si ce déclencheur a été déclenché après l'enregistrement de tous les enregistrements.</td>
                  </tr>
                  <tr>
                    <td>isUndelete</td>
                    <td>Renvoie true si ce déclencheur a été déclenché après qu'un enregistrement a été récupéré dans la Corbeille. Cette récupération peut se produire après une opération d'insuppression à partir de l'interface utilisateur Salesforce, d'Apex ou de l'API.</td>
                  </tr>
                  <tr>
                    <td>nouveau</td>
                    <td>Renvoie une liste des nouvelles versions des enregistrements sObject. Cette liste sObject n'est disponible que dans les déclencheurs d'insertion, de mise à jour et de suppression, et les enregistrements ne peuvent être modifiés qu'avant les déclencheurs.</td>
                  </tr>
                  <tr>
                    <td>newMap</td>
                    <td>Une carte des ID aux nouvelles versions des enregistrements sObject. Cette carte n'est disponible qu'avant la mise à jour, après l'insertion, après la mise à jour et après la suppression des déclencheurs.</td>
                  </tr>
                  <tr>
                    <td>vieux</td>
                    <td>Renvoie une liste des anciennes versions des enregistrements sObject. Cette liste sObject n'est disponible que dans les déclencheurs de mise à jour et de suppression.</td>
                  </tr>
                  <tr>
                    <td>oldMap</td>
                    <td>Une carte des ID aux anciennes versions des enregistrements sObject. Cette carte n'est disponible que dans les déclencheurs de mise à jour et de suppression.</td>
                  </tr>
                  <tr>
                    <td>operationType</td>
                    <td>Renvoie une énumération de type System.TriggerOperation correspondant à l’opération en cours.Possible values of the System.TriggerOperation enum are: BEFORE_INSERT, BEFORE_UPDATE, BEFORE_DELETE, AFTER_INSERT, AFTER_UPDATE, AFTER_DELETE, and AFTER_UNDELETE. Si vous variez votre logique de programmation en fonction de différents types de déclencheurs, envisagez d'utiliser l'instruction switch avec différentes permutations d'états d'énumération d'exécution de déclencheur unique.</td>
                  </tr>
                  <tr>
                    <td>taille</td>
                    <td>Le nombre total d'enregistrements dans une invocation de déclencheur, anciens et nouveaux.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Let’s write our <code>NameReplacer</code> trigger:</p>
            <pre><code>trigger NameReplacer on Contact(before insert, after update){
    if (Trigger.isBefore &amp;&amp; Trigger.isInsert){
        firstName();
    }
    if (Trigger.isAfter &amp;&amp; Trigger.isUpdate){
        lastName();
    }
}</code></pre>
            <p>Alternatively, this can be written in nested <code>if</code> statements:</p>
            <pre><code>trigger NameReplacer on Contact(before insert, after update){
    if (Trigger.isBefore){
        if(Trigger.isInsert){
            firstName();
        }
    }

    if (Trigger.isAfter){
        if(Trigger.isUpdate){
            lastName();
        }
    }
}</code></pre>
            <p>Either ways works and is on the developer to choose which format they prefer. Personally, I prefer nesting inside <code>if</code> statements to keep the file easily
              readable. We will look into remaining Trigger Context Variables like <code>oldMap</code> and <code>newMap</code> in the next chapter.</p>
            <p>La question suivante qui vient instantanément est <em>Pourquoi écrire des déclencheurs lorsque Flows/Process Builder/Workflow peut être utilisé à la place ?</em>. Une réponse très simple pour les fonctionnalités qui se chevauchent (comme la mise à jour d'un enregistrement) est purement sur <em>ce que vous préférez</em>. Si je travaille sur une organisation et que j'ai besoin de mettre à jour les contacts en fonction d'un critère, j'écrirai une classe trigger et helper parce que je suis à l'aise avec elle, mais mon collègue qui est administrateur pourrait finir par faire un flux qui fait le même travail. Outre la préférence, les déclencheurs excellent en fait lorsqu'il s'agit de tester des automatismes plus complexes qui peuvent être effectuées à l'aide de flux, et nécessitent moins de puissance de calcul pour s'exécuter, ce qui les rend plus rapides. Là où les déclencheurs, ou l'écriture d'Apex en général manque de retard, c'est le fait que <em>vous ne pouvez pas écrire votre code en production</em>. Tout le code Apex doit être dans un environnement sandbox et doit passer une couverture de code de 75 % pour être mis en production.</p>
            <p>Nous examinons plus en détail les classes de test Apex et d'autres exigences techniques plus tard dans le cours.</p>
            <h1>Résumé</h1>
            <ul>
              <li>Les déclencheurs s'exécutent lorsqu'un enregistrement est manipulé.</li>
              <li>Les déclencheurs doivent être écrits avec une classe d'aide.</li>
              <li>Les variables de contexte de déclenchement vous permettent d'accéder au contexte d'exécution.</li>
              <li>L'ordre d'exécution est la façon dont un enregistrement passe du texte à l'écran à l'enregistrement dans la base de données.</li>
              <li>Use a <code>before</code> trigger by default and <code>after</code> trigger when usage of ID is required.</li>
            </ul>


            <a href="12.html" class="global-button">Jour 12 : Trigger.oldMap et Trigger.newMap</a>
          </div>
        </article>

      </main>
      <footer class="footer-section global-footer">
        <div class="footer-copyright">© <a href="http://harshdeephura.com" target="_blank">Harshdeep Singh Hura</a>.<br>Tous droits réservés.</div>
      </footer>
    </div>
  </div>




  <script src="../assets/js/global.js"></script>




</body></html>
